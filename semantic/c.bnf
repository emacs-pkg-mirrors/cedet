# C & C++ BNF language specification
#
# Copyright (C) 1999, 2000, 2001 Eric M. Ludlam
#
# Author: Eric M. Ludlam <zappo@gnu.org>
# X-RCS: $Id: c.bnf,v 1.27 2001/02/09 19:49:26 zappo Exp $
#
# c.bnf is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Emacs; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# $Log: c.bnf,v $
# Revision 1.27  2001/02/09 19:49:26  zappo
# Added ( testing to argument lists.
#
# Revision 1.26  2001/02/09 11:47:32  zappo
# Added type separation characters.
# Added all constituents of DECLMOD into their own tokens.
# Created a rule to create a list of declmods.
#
# Revision 1.25  2001/02/02 04:14:53  zappo
# Added c++ to the list of language modes.
# Added lots of operator symbol tokens.
# Added DECLMOD symbol w/ complex regexp.
# Added CLASS, OPERATOR, PUBLIC, PRIVATE, and PROTECTED token keywords.
# Support parsing of a class.
# Add class bit parsing for functions.
# Add destructor bit parsing for functions.
# Allow operator symbols for methods.
# Added parent and destructor fields to extra-spec for functions.
# The function rule now returns a function or prototype.
#
# Revision 1.24  2001/01/31 15:26:10  zappo
# Added `codeblock' rule and `%scopestart'.
#
# Revision 1.23  2001/01/24 21:08:41  zappo
# Added support for new token formats that use ASSOC.
#
# Revision 1.22  2001/01/06 14:35:40  zappo
# Put `type' `t' onto some tokens.
# Struct and enums now match the braces, and return nil.
# Enum parts now have a token type of 'enum.
# Added ... to fuction arg lists.
# Match parens for arg lists.
#
# [...]
#
# Revision 1.1  1999/05/17 17:28:30  zappo
# Initial revision
#

%start         declaration
%scopestart    codeblock
%outputfile    semantic-c.el
%parsetable    semantic-toplevel-c-bovine-table
%keywordtable  semantic-c-keyword-table
%languagemode  (c-mode c++-mode)
%setupfunction semantic-default-c-setup

%(setq semantic-expand-nonterminal 'semantic-expand-c-nonterminal
       semantic-flex-extensions semantic-flex-c-extensions
       semantic-dependency-include-path semantic-default-c-path
       imenu-create-index-function 'semantic-create-imenu-index
       semantic-type-relation-separator-character '("." "->")
       semantic-command-separation-character ";"
       document-comment-start "/*"
       document-comment-line-prefix " *"
       document-comment-end " */"
       )%

%token HASH punctuation "#"
%token INCLUDE "include"
%token DEFINE "define"
%token PERIOD punctuation "."
%token COLON punctuation ":"
%token SEMICOLON punctuation ";"
%token STAR punctuation "*"
%token DIVIDE punctuation "/"
%token PLUS punctuation "+"
%token MINUS punctuation "-"
%token BANG punctuation "!"
%token EQUAL punctuation "="
%token LESS punctuation "<"
%token GREATER punctuation ">"
%token COMA punctuation ","
%token TILDE punctuation "~"

%token EXTERN "extern"
%token STATIC "static"
%token CONST "const"
%token VOLATILE "volatile"
%token SIGNED "signed"
%token UNSIGNED "unsigned"
%token VIRTUAL "virtual"

%token STRUCT "struct"
%token UNION "union"
%token ENUM "enum"
%token TYPEDEF "typedef"
%token CLASS "class"

%token OPERATOR "operator"
%token PUBLIC "public"
%token PRIVATE "private"
%token PROTECTED "protected"

%put STRUCT type t
%put UNION type t
%put TYPEDEF type t
%put CLASS type t

declaration : include
	    | macro
	    | type
	    | function
	    | variable
	    | define
	    ;

codeblock : macro
	  | define
	  | variable
	  | prototype
	  | type # type is less likely to be used here.
	  ;
		
include : HASH INCLUDE punctuation "<" filename punctuation ">"
	  ( ,$4 include t nil )
        | HASH INCLUDE string
	  ( (read $3) include nil nil )
        ;

filename : symbol PERIOD symbol
	   ( (concat $1 $2 $3) )
         | symbol punctuation "/" filename
	   ( (concat $1 $2 (car $3)) )
	 ;

structparts : semantic-list
	      (EXPANDFULL $1 structsubparts)
	    ;

structsubparts : variable
	       | define
	       | open-paren "{"
		 ( nil )
	       | close-paren "}"
		 ( nil )
	       # sometimes there are defines in structs.
	       ;

classparts : semantic-list
	     (EXPANDFULL $1 classsubparts)
	    ;

classsubparts : variable
	      | define
	      | function
	      | opt-class-protection COLON
	      # In C++, this label in a classsubpart represents
	      # PUBLIC or PRIVATE bits.  Ignore them for now.
		(nil)
	      | open-paren "{"
		( nil )
	      | close-paren "}"
		( nil )
	      ;

opt-class-parents : COLON opt-class-protection symbol
		    ( $3 )
		  | EMPTY
		    ( )
		  ;

opt-class-protection : PUBLIC
		     | PRIVATE
		     | PROTECTED
		     ;

enumparts : semantic-list
	    (EXPANDFULL $1 enumsubparts)
	  ;

enumsubparts : symbol opt-assign
	       ( $1 enum )
	     | open-paren "{"
	       ( nil )
	     | close-paren "}"
	       ( nil )
	     ;

opt-name : symbol
	 | EMPTY
	   ( nil )
         ;

typesimple : STRUCT opt-name structparts
	     ( ,$2 type $1 $3 nil nil nil )
	   | UNION opt-name structparts
	     ( ,$2 type $1 $3 nil nil nil )
	   | ENUM opt-name enumparts
	     ( ,$2 type $1 $3 nil nil nil )	
           | CLASS symbol opt-class-parents classparts
	     ( $2 type $1 $4 ,$3 nil nil )
           | TYPEDEF typeform symbol
	     ( $3 type $1 nil $2 nil nil )
           ;

type : typesimple SEMICOLON
       ( ,$1 )
     ;

opt-stars : STAR opt-stars
	    ( (1+ (car $2)) )
	  | EMPTY
	    ( 0 )
          ;

declmods : DECLMOD declmods
	   ( ,(cons ,$1 $2 ) )
	 | DECLMOD
	   ( ,$1 )
	 | EMPTY
	   ()
	 ;

DECLMOD : EXTERN
	| STATIC
	| CONST
	| VOLATILE
	| SIGNED
	| UNSIGNED
	| VIRTUAL
	;

# Don't deal with the stars just yet.
typeform : typeformbase opt-stars
	   ( ,$1 )
	 ;

typeformbase : typesimple
	       ( ,$1 )
	     | STRUCT symbol
	       ( $2 type $1 )
	     | UNION symbol
	       ( $2 type $1 )
	     | ENUM symbol
	       ( $2 type $1 )
	     | symbol
	       ( $1 )
	     ;
  
opt-bits : COLON symbol
	   ( $2 )
	 | EMPTY
	   ( nil )
	 ;

opt-array : semantic-list "\\[.*\\]$" opt-array
	  # Eventually we want to replace the 1 below with a size
	  # (if available)
	    ( (cons 1 (car ,$2) ) )
	  | EMPTY
	    ( nil )
          ;

opt-assign : EQUAL expression
	     ( $2 )
	   | EMPTY
	     ( nil )
	   ;

macro : HASH DEFINE symbol opt-expression
	( $3 variable nil $4
	     (ASSOC const t)
	     nil
	      )
      ;

variable : variabledef SEMICOLON
	   ( ,$1 )
	 ;

variabledef : declmods typeform varnamelist
	      ( $3 variable $2
		   ;; default value
		   nil
		   ;; modifiers
		   (ASSOC const (if (member "const" $1) t nil)
			  typemodifiers (delete "const" $1))
		   nil
		    )
	    ;

opt-restrict : symbol "\\<\\(__\\)?restrict\\>"
	     | EMPTY
	     ;

varname : opt-stars opt-restrict symbol opt-bits opt-array opt-assign
	  ( $3 ,$1 ,$4 ,$5 ,$6 )
	;

# I should store more in this def, but leave it simple for now.
variablearg : declmods typeform varname
	      ( (car $3) variable $2 nil
		 (ASSOC const (if (member "const" $1) t nil)
			typemodifiers (delete "const" $1))
		 nil
		 )
	    ;

varnamelist : varname COMA varnamelist
	      ( ,(cons $1 $3) )
            | varname
	      ( $1 )
	    ;

opt-class : symbol COLON COLON
	    ( $1 )
	  | EMPTY
	    ( nil )
	  ;

opt-destructor : TILDE
		 ( t )
	       | EMPTY
		 ( nil )
	       ;

arg-list : symbol "\\<__?P\\>" semantic-list
	   (EXPAND $2 arg-list-p)
	 | semantic-list "^(" knr-arguments
	   ( ,$2 )
	 | semantic-list "^("
	   (EXPANDFULL $1 arg-sub-list)
	 ;

knr-arguments : variablearg SEMICOLON knr-arguments
		( ,(cons $1 $3) )
	      | variablearg SEMICOLON
		( $1 )
	      ;

arg-list-p : open-paren "(" semantic-list close-paren ")"
	     (EXPANDFULL $2 arg-sub-list)
	   ;

arg-sub-list : variablearg
	       ( ,$1 )
	     | PERIOD PERIOD PERIOD close-paren ")"
	       ( "..." )
	     | open-paren "("
	       ( nil )
	     | close-paren ")"
	       ( nil )
	     ;

operatorsym : LESS LESS
	      ( "<<" )
	    | GREATER GREATER
	      ( ">>" )
	    | EQUAL EQUAL
	      ( "==" )
	    | LESS EQUAL
	      ( "<=" )
	    | GREATER EQUAL
	      ( ">=" )
	    | BANG EQUAL
	      ( "!=" )
	    | LESS
	    | GREATER
	    | STAR
	    | PLUS
	    | MINUS
	    | DIVIDE
	    ;

functionname : OPERATOR operatorsym
	       ( ,$2 )
	     | symbol
	       ( $1 )
	     ;

functiondef : declmods typeform opt-class opt-destructor functionname arg-list
	      ( ,$5 function $2 $6
		   (ASSOC const (if (member "const" $1) t nil)
			  typemodifiers (delete "const" $1)
			  parent (car $3)
			  destructor (car $4) )
		   nil
		    )
            ;

prototype : functiondef SEMICOLON
	    ( ,$1 )
	  ;

function : functiondef fun-or-proto-end
	   ( ,$1 )
         ;

fun-or-proto-end: SEMICOLON
		  ( t )
		| semantic-list
		  ( nil )
		;

opt-expression : expression
	       | EMPTY ( nil )
	       ;

# Use expression for parsing only.  Don't actually return anything
# for now.  Hopefully we can fix this later.
expression : symbol
	     ( )
           | punctuation "[!*&~]" symbol
	     ( )
           | semantic-list
	     ( )
	   # | expression "+-*/%^|&" expression
	   # ( nil )
	   ;
