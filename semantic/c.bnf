# C & C++ BNF language specification
#
# Copyright (C) 1999, 2000, 2001 Eric M. Ludlam
#
# Author: Eric M. Ludlam <zappo@gnu.org>
# X-RCS: $Id: c.bnf,v 1.47 2001/10/08 21:12:17 zappo Exp $
#
# c.bnf is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Emacs; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# $Log: c.bnf,v $
# Revision 1.47  2001/10/08 21:12:17  zappo
# (unionpartsparts): new rule; used to be classparts
# (typesimple): When building a class, store off the classname found.
# Used to reconstitute functions later.
# (var-or-fun): Re-enable untyped functions and variables.
#
# Revision 1.46  2001/10/05 19:36:38  zappo
# (var-or-fun): Disable support (for now) of int declarations for vars
# and funs with unspecified types.  Who does that anymore anyway?
#
# Revision 1.45  2001/10/05 02:01:11  zappo
# (UNDERP, UNDERUNDERP): New keywords
# (macro-or-include): Handle optional argument list
# (opt-define-arglist): New rules
# (var-or-func-decl): Account for optional _P before arglist.
# (opt-under-p): New rule
# (arg-list): Remove check for _P here.  Regex wasn't working.
# (arg-sub-list): Unused.
# (expression): Add symbol as valid part.
#
# Revision 1.44  2001/10/04 15:00:48  zappo
# (expression): Use newer number token which handles floats.
#
# Revision 1.43  2001/10/03 00:44:13  zappo
# (INLINE): Fix typo
# (opt-class-protection): EMPTY is valid match
# (opt-name): UNION can have class parts.  Fix typedef name.
# (DECLMOD): Add METADECLMOD
# (metadeclmod, METADECLMOD): New rules
# (var-or-fun-decl): Accept metadeclmods in the middle.
# (fun-or-proto-end): Accept "= 0;" as a valid function end.
# (opt-expression): Deal with numbers.
#
# Revision 1.42  2001/09/26 23:54:20  zappo
# (enumsubparts): Account for commas
# (arg-sub-list): Account for commas
# (opt-expression): Account for floating point numbers,
# or struct dereferences.
#
# Revision 1.41  2001/09/12 04:42:54  zappo
# (var-or-func-decl): Change to host multiple postfix fcn modifiers, and
# initializers.
# (opt-reentrant): deleted
# (opt-initializers, opt-post-fcn-modifiers, post-fcn-modifiers): New rules
#
# Revision 1.40  2001/08/18 04:06:50  zappo
# Fixed the inclusion of * in variables and functions.
#
# Revision 1.39  2001/08/17 21:02:13  zappo
# Added register.
# Added template w/ comment, but don't use it.
#
# Revision 1.38  2001/08/01 14:34:54  zappo
# Support reentrant.
#
# Revision 1.37  2001/06/03 14:01:13  zappo
# Multi-inheritance for classes.
# Structs like classes for C++.
# No ; on name spaces.
# Throws for methods.
# (Bugs & patches from "Jesper Nordenberg" <mayhem@home.se>
# and Norbert Lindlbauer <Norbert_Lindlbauer@betaresearch.de>)
#
# Revision 1.36  2001/05/25 01:12:10  zappo
# (expression): Added string.
#
# Revision 1.35  2001/05/09 03:25:17  zappo
# Added inline method support.
# Store protection elements
# Change enum parts to be integer variables.
#
# Revision 1.34  2001/05/01 16:52:40  zappo
# Revamped lots of summary strings.
# Added `type' as a possible expansion in classsubparts.
#
# Revision 1.33  2001/04/21 14:37:55  zappo
# Spelling error for integer.
#
# Revision 1.32  2001/04/13 02:24:45  zappo
# Added built in types (void, char, etc) and summaries.
#
# Revision 1.31  2001/04/07 02:43:48  zappo
# Added name spaces, and references.
#
# Revision 1.30  2001/03/10 16:18:15  zappo
# Added lots of summaries to %tokens.
# variables and functions now share declmod and typedecl start
# match, and then get recombobulated later.  Prevents massive
# reparsing.
#
# Revision 1.29  2001/02/24 15:24:24  zappo
# Added a few optimizations for structure parts.
# Used some %tokens in a few spots where I wasn't using them before.
#
# Revision 1.28  2001/02/20 20:36:19  zappo
# Removed unused %put calls.
#
# Revision 1.27  2001/02/09 19:49:26  zappo
# Added paren testing to argument lists.
#
# Revision 1.26  2001/02/09 11:47:32  zappo
# Added type separation characters.
# Added all constituents of DECLMOD into their own tokens.
# Created a rule to create a list of declmods.
#
# Revision 1.25  2001/02/02 04:14:53  zappo
# Added c++ to the list of language modes.
# Added lots of operator symbol tokens.
# Added DECLMOD symbol w/ complex regexp.
# Added CLASS, OPERATOR, PUBLIC, PRIVATE, and PROTECTED token keywords.
# Support parsing of a class.
# Add class bit parsing for functions.
# Add destructor bit parsing for functions.
# Allow operator symbols for methods.
# Added parent and destructor fields to extra-spec for functions.
# The function rule now returns a function or prototype.
#
# Revision 1.24  2001/01/31 15:26:10  zappo
# Added `codeblock' rule and `%scopestart'.
#
# Revision 1.23  2001/01/24 21:08:41  zappo
# Added support for new token formats that use ASSOC.
#
# Revision 1.22  2001/01/06 14:35:40  zappo
# Put `type' `t' onto some tokens.
# Struct and enums now match the braces, and return nil.
# Enum parts now have a token type of 'enum.
# Added ... to fuction arg lists.
# Match parens for arg lists.
#
# [...]
#
# Revision 1.1  1999/05/17 17:28:30  zappo
# Initial revision
#

%start         declaration
%scopestart    codeblock
%outputfile    semantic-c.el
%parsetable    semantic-toplevel-c-bovine-table
%keywordtable  semantic-c-keyword-table
%languagemode  (c-mode c++-mode)
%setupfunction semantic-default-c-setup

%(setq semantic-expand-nonterminal 'semantic-expand-c-nonterminal
       semantic-flex-extensions semantic-flex-c-extensions
       semantic-dependency-include-path semantic-default-c-path
       imenu-create-index-function 'semantic-create-imenu-index
       semantic-type-relation-separator-character '("." "->")
       semantic-command-separation-character ";"
       document-comment-start "/*"
       document-comment-line-prefix " *"
       document-comment-end " */"
       ;; Semantic navigation inside 'type children
       senator-step-at-token-ids '(function variable)
       )%

%token INCLUDE "include"
%token DEFINE "define"
%token HASH punctuation "#"
%token PERIOD punctuation "."
%token COLON punctuation ":"
%token SEMICOLON punctuation ";"
%token STAR punctuation "*"
%token AMPERSAND punctuation "&"
%token DIVIDE punctuation "/"
%token PLUS punctuation "+"
%token MINUS punctuation "-"
%token BANG punctuation "!"
%token EQUAL punctuation "="
%token LESS punctuation "<"
%token GREATER punctuation ">"
%token COMA punctuation ","
%token TILDE punctuation "~"

%token EXTERN "extern"
%put EXTERN summary "Declaration Modifier: extern <type> <name> ..."
%token STATIC "static"
%put STATIC summary "Declaration Modifier: static <type> <name> ..."
%token CONST "const"
%put CONST summary "Declaration Modifier: const <type> <name> ..."
%token VOLATILE "volatile"
%put VOLATILE summary "Declaration Modifier: volatile <type> <name> ..."
%token REGISTER "register"
%put REGISTER summary "Declaration Modifier: register <type> <name> ..."
%token SIGNED "signed"
%put SIGNED summary "Numeric Type Modifier: signed <numeric type> <name> ..."
%token UNSIGNED "unsigned"
%put UNSIGNED summary "Numeric Type Modifier: unsigned <numeric type> <name> ..."

%token INLINE "inline"
%put INLINE summary "Function Modifier: inline <return  type> <name>(...) {...};"
%token VIRTUAL "virtual"
%put VIRTUAL summary "Method Modifier: virtual <type> <name>(...) ..."

%token STRUCT "struct"
%put STRUCT summary "Structure Type Declaration: struct [name] { ... };"
%token UNION "union"
%put UNION summary "Union Type Declaration: union [name] { ... };"
%token ENUM "enum"
%put ENUM summary "Enumeration Type Declaration: enum [name] { ... };"
%token TYPEDEF "typedef"
%put TYPEDEF summary "Arbitrary Type Declaration: typedef <typedeclaration> <name>;"
%token CLASS "class"
%put CLASS summary "Class Declaration: class <name>[:parents] { ... };"
%token NAMESPACE "namespace"
%put NAMESPACE summary "Namespace Declaration: namespace <name> { ... };"

# Despite this, this parser can find templates by ignoring the TEMPLATE
# keyword, and finding the class/method being templateized.
%token TEMPLATE "template"
%put TEMPLATE summary "template <class TYPE ...> TYPE_OR_FUNCTION"

%token THROW "throw"
%put THROW summary "<type> <methoddef> (<method args>) throw (<exception>) ..."
%token REENTRANT "reentrant"
%put REENTRANT summary "<type> <methoddef> (<method args>) reentrant ..."

# Leave these alone for now.
%token OPERATOR "operator"
%token PUBLIC "public"
%token PRIVATE "private"
%token PROTECTED "protected"


# These aren't used for parsing, but is a useful place to describe the keywords.
%token IF "if"
%token ELSE "else"
%put {IF ELSE} summary  "if (<condition>) { code } [ else { code } ]"

%token DO "do"
%token WHILE "while"
%put DO summary " do { code } while (<condition>);"
%put WHILE summary "do { code } while (<condition>); or while (<condition>) { code };"

%token FOR "for"
%put FOR summary "for(<init>; <condition>; <increment>) { code }"

%token SWITCH "switch"
%token CASE "case"
%token DEFAULT "default"
%put {SWITCH CASE DEFAULT} summary
"switch (<variable>) { case <constvalue>: code; ... default: code; }"

%token RETURN "return"
%put RETURN summary "return <value>;"

%token BREAK "break"
%put BREAK summary "Non-local exit within a loop or switch (for, do/while, switch): break;"
%token CONTINUE "continue"
%put CONTINUE summary "Non-local continue within a lool (for, do/while): continue;"

%token SIZEOF "sizeof"
%put SIZEOF summary "Compile time macro: sizeof(<type or variable>) // size in bytes"

# Types
%token VOID "void"
%put VOID summary "Built in typeless type: void"
%token CHAR "char"
%put CHAR summary "Integral Character Type: (0 to 256)"
%token SHORT "short"
%put SHORT summary "Integral Primitive Type: (-32768 to 32767)"
%token INT "int"
%put INT summary "Integral Primitive Type: (-2147483648 to 2147483647)"
%token LONG "long"
%put LONG summary "Integral primitive type (-9223372036854775808 to 9223372036854775807)"
%token FLOAT "float"
%put FLOAT summary "Primitive floating-point type (single-precision 32-bit IEEE 754)"
%token DOUBLE "double"
%put DOUBLE summary "Primitive floating-point type (double-precision 64-bit IEEE 754)"

%token UNDERP "_P"
%token UNDERUNDERP "__P"
%put UNDERP summary "Common macro to elimitate prototype compatibility on some compilers"
%put UNDERUNDERP summary "Common macro to elimitate prototype compatibility on some compilers"

declaration : macro
	    | type
	    | var-or-fun
	    | define
	    ;

codeblock : define
	  | var-or-fun
	  | type # type is less likely to be used here.
	  ;

macro : HASH macro-or-include
	( ,$2 )
      ;

macro-or-include : DEFINE symbol opt-define-arglist opt-expression
		   ( $2 variable nil $3
			(ASSOC const t)
			nil
			)
		 | INCLUDE LESS filename GREATER
		   ( ,$3 include t nil )
		 | INCLUDE string
		   ( (read $2) include nil nil )
		 ;

opt-define-arglist : semantic-list
		     ( nil )
		   | EMPTY
		   ;

# This is used in struct parts.
define : HASH DEFINE symbol opt-expression
	 ( $2 variable nil $3
	      (ASSOC const t)
	      nil
	      )
       ;

filename : symbol PERIOD symbol
	   ( (concat $1 $2 $3) )
         | symbol DIVIDE filename
	   ( (concat $1 $2 (car $3)) )
	 ;

# In C++, structures can have the same things as classes.
# So delete this somday in the figure.
#
#structparts : semantic-list
#	      (EXPANDFULL $1 structsubparts)
#	    ;
#
#structsubparts : open-paren "{"
#		 ( nil )
#	       | close-paren "}"
#		 ( nil )
#	       | var-or-fun
#	       | define
#	       # sometimes there are defines in structs.
#	       ;

unionpartsparts : semantic-list
		  (EXPANDFULL $1 classsubparts)
		;

classsubparts : open-paren "{"
		( nil )
	      | close-paren "}"
		( nil )
	      | opt-class-protection COLON
		( ,$1 label )
	      | var-or-fun
	      | type
	      | define	      
		( ,$1 protection )
	      # In C++, this label in a classsubpart represents
	      # PUBLIC or PRIVATE bits.  Ignore them for now.
	      | EMPTY
	      ;

opt-class-parents : COLON class-parents
		    ( $2 )
		  | EMPTY
		    ( )
		  ;

class-parents : opt-class-protection symbol COMA class-parents
		( ,(cons $2 $4 ) )
	      | opt-class-protection symbol
		( $2 )
	      ;

opt-class-protection : PUBLIC
		     | PRIVATE
		     | PROTECTED
		     | EMPTY
		     ;

namespaceparts : semantic-list
		 (EXPANDFULL $1 namespacesubparts)
	       ;

namespacesubparts : open-paren "{"
		    ( nil )
		  | close-paren "}"
		    ( nil )
		  | type
                  | var-or-fun
		  | define
		  | opt-class-protection COLON
		    ( $1 protection )
		  # In C++, this label in a classsubpart represents
		  # PUBLIC or PRIVATE bits.  Ignore them for now.
		  | EMPTY
		  ;

enumparts : semantic-list
	    (EXPANDFULL $1 enumsubparts)
	  ;

enumsubparts : symbol opt-assign
	       ( $1 variable "int" ,$2 (ASSOC const t) nil)
	     | open-paren "{"
	       ( nil )
	     | close-paren "}"
	       ( nil )
	     | COMA
	       ( nil )
	     ;

opt-name : symbol
	 | EMPTY
	   ( nil )
         ;

typesimple : struct-or-class opt-name opt-class-parents semantic-list
	     ( ,$2 type ,$1 
		   (let ((semantic-c-classname (cons (car ,$2) (car ,$1))))
		       (EXPANDFULL $4 classsubparts))
		   ,$3 nil nil )
	   | UNION opt-name classparts
	     ( ,$2 type $1 $3 nil nil nil )
	   | ENUM opt-name enumparts
	     ( ,$2 type $1 $3 nil nil nil )	
           | TYPEDEF typeformbase opt-stars symbol
	     ( $4 type $1 nil $2 nil nil )
           ;

struct-or-class: STRUCT
	       | CLASS
	       ;

type : typesimple SEMICOLON
       ( ,$1 )
     | NAMESPACE symbol namespaceparts
       ( $2 type $1 $3 nil nil nil )
     ;

opt-stars : STAR opt-stars
	    ( (1+ (car $2)) )
	  | EMPTY
	    ( 0 )
          ;

declmods : DECLMOD declmods
	   ( ,(cons ,(car ,$1) $2 ) )
	 | DECLMOD
	   ( ,$1 )
	 | EMPTY
	   ()
	 ;

DECLMOD : EXTERN
	| STATIC
	| CONST
	| VOLATILE
	| SIGNED
	| UNSIGNED
	| INLINE
	| REGISTER
	| METADECLMOD
	;

metadeclmod : METADECLMOD
	      ()
	    | EMPTY
	      ()
	    ;

METADECLMOD : VIRTUAL
	    ;

# C++: A type can be modified into a reference by "&"
opt-ref : AMPERSAND
	| EMPTY
	;

typeformbase : typesimple
	       ( ,$1 )
	     | STRUCT symbol
	       ( $2 type $1 )
	     | UNION symbol
	       ( $2 type $1 )
	     | ENUM symbol
	       ( $2 type $1 )
	     | builtintype
	       ( ,$1 )
	     | symbol
	       ( $1 )
	     ;

builtintype : VOID
	    | CHAR
	    | SHORT
	    | INT
	    | LONG
	    | FLOAT
	    | DOUBLE
	    ;

var-or-fun : declmods typeformbase metadeclmod opt-ref var-or-func-decl
	     ( ,(semantic-c-reconstitute-token ,$5 $1 $2 ) )
	   # it is possible for a function to not have a type, and
	   # it is then assumed to be an int.  How annoying.
	   # In C++, this could be a constructor or a destructor.
	   # Even more annoying.
	   | declmods var-or-func-decl
	     ( ,(semantic-c-reconstitute-token ,$2 $1 nil ) )
	   ;

var-or-func-decl : opt-stars opt-class opt-destructor functionname opt-under-p arg-list 
		   opt-post-fcn-modifiers
		   opt-throw
		   opt-initializers
		   fun-or-proto-end
		   ( ,$4 'function 
			 ;; Extra stuff goes in here.
			 ;; Continue with the stuff we found in
			 ;; this definition
			$2 $3 $6 $8 ,$7 ,$1 ,$10)
		 | varnamelist  SEMICOLON
		   ( $1 'variable )
		 ;

opt-under-p : UNDERP
	      (nil)
	    | UNDERUNDERP
	      (nil)
	    | EMPTY
	    ;

opt-initializers: COLON symbol semantic-list opt-initializers
		| COMA symbol semantic-list opt-initializers
		| EMPTY
		;

opt-post-fcn-modifiers : post-fcn-modifiers opt-post-fcn-modifiers
			 ( ,(cons ,$1 $2) )
		       | EMPTY
			 ( nil )
		       ;

post-fcn-modifiers : REENTRANT
		   | CONST
		   ;

opt-throw : THROW semantic-list
	     ( EXPAND $2 throw-exception-list )
	   | EMPTY
	   ;

# Is this true?  I don't actually know.
throw-exception-list : symbol COMA throw-exception-list
			( ,(cons $1 $3) )
		      | symbol close-paren ")"
			( $1 )
		     | open-paren "(" throw-exception-list
			( ,$2 )
		      ;

opt-bits : COLON symbol
	   ( $2 )
	 | EMPTY
	   ( nil )
	 ;

opt-array : semantic-list "\\[.*\\]$" opt-array
	  # Eventually we want to replace the 1 below with a size
	  # (if available)
	    ( (cons 1 (car ,$2) ) )
	  | EMPTY
	    ( nil )
          ;

opt-assign : EQUAL expression
	     ( $2 )
	   | EMPTY
	     ( nil )
	   ;

opt-restrict : symbol "\\<\\(__\\)?restrict\\>"
	     | EMPTY
	     ;

varname : opt-stars opt-restrict symbol opt-bits opt-array opt-assign
	  ( $3 ,$1 ,$4 ,$5 ,$6 )
	;

# I should store more in this def, but leave it simple for now.
variablearg : declmods typeformbase opt-stars opt-ref varname
	      ( (car $5) variable $2 nil
		 (ASSOC const (if (member "const" $1) t nil)
			typemodifiers (delete "const" $1)
			pointer (car ,$3)
			)
		 nil
		 )
	    ;

varnamelist : varname COMA varnamelist
	      ( ,(cons $1 $3) )
            | varname
	      ( $1 )
	    ;

opt-class : symbol COLON COLON
	    ( $1 )
	  | EMPTY
	    ( nil )
	  ;

opt-destructor : TILDE
		 ( t )
	       | EMPTY
		 ( nil )
	       ;

arg-list : semantic-list "^(" knr-arguments
	   ( ,$2 )
	 | semantic-list "^("
	   (EXPANDFULL $1 arg-sub-list)
	 ;

knr-arguments : variablearg SEMICOLON knr-arguments
		( ,(cons $1 $3) )
	      | variablearg SEMICOLON
		( $1 )
	      ;

arg-sub-list : variablearg
	       ( ,$1 )
	     | PERIOD PERIOD PERIOD close-paren ")"
	       ( "..." )
	     | COMA
	       ( nil )
	     | open-paren "("
	       ( nil )
	     | close-paren ")"
	       ( nil )
	     ;

operatorsym : LESS LESS
	      ( "<<" )
	    | GREATER GREATER
	      ( ">>" )
	    | EQUAL EQUAL
	      ( "==" )
	    | LESS EQUAL
	      ( "<=" )
	    | GREATER EQUAL
	      ( ">=" )
	    | BANG EQUAL
	      ( "!=" )
	    | LESS
	    | GREATER
	    | STAR
	    | PLUS
	    | MINUS
	    | DIVIDE
	    | EQUAL
	    ;

functionname : OPERATOR operatorsym
	       ( ,$2 )
	     | symbol
	       ( $1 )
	     ;

fun-or-proto-end: SEMICOLON
		  ( t )
		| semantic-list
		  ( nil )
		# Here is an anoying feature of C++ pure virtual methods
		| EQUAL number "^0$" SEMICOLON
		  ( t )
		;

opt-expression : expression
	       | EMPTY ( nil )
	       ;

# Use expression for parsing only.  Don't actually return anything
# for now.  Hopefully we can fix this later.
expression : number
	     ( )
	   | symbol
	     ( )
	   | string
	     ( )
           | semantic-list
	     ( )
	   | punctuation "[-+*/%^|&]" expression
	   # ( nil )
	   ;
