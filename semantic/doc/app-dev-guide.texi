@ignore
@node Application Developer's Guide
@chapter Application Developer's Guide
@c This 'ignore' section fools texinfo-all-menus-update into creating
@c proper menus for this chapter.
@end ignore

A @semantic{} application takes the semantic tags generated
by semantic parsers then provides useful services to the user.
See @ref{Semantic User's Guide} for a list of such applications.

An application developer needs to know
@itemize @bullet
@item when to invoke the parser to generate or regenerate the tag lists.
@item how to access the tag lists.
@item how to access information about each tag.
@end itemize

This chapter describes @semantic{} fuctions and concepts an application
developer needs to know to perform all of the tasks just listed.

@menu
* Semantic Tags::               
* Tag Tables::                  Working with tag tables.
* Tags at Point::               Finding tags at point.
* Tag Sorting::                 Reorganizing streams.
* Tag Completion::              Completing read functions.
* Override Methods::            Language dependent functions covering
                                conversion to text strings, language dependent
                                queries and local context information
* Parser Hooks::                How to know when tags change.
* Semantic Database::           Persistant storage of tags.
* Example Programs::            Simple programming examples.
* Current Context::             
@end menu

@node Semantic Tags
@section Semantic Tags

@lowersections
@include tags.texi
@raisesections

@node Tag Tables
@section tag tables

These functions take some key, and returns information found in a tag
table.  Some will return one tag (the first matching item found.)
Others will return a list of all items matching a given criterion.
All these functions work regardless of a buffer being in memory or
not.

@defun semantic-brute-find-first-tag-by-name name streamorbuffer &optional search-parts search-include
Find a tag @var{NAME} within @var{STREAMORBUFFER}.  @var{NAME} is a string.
If @var{SEARCH-PARTS} is non-@code{nil}, search children of tags.
If @var{SEARCH-INCLUDE} is non-@code{nil}, search include files.

Use @dfn{semantic-find-first-tag-by-name} instead.

@obsolete{semantic-find-nonterminal-by-name,semantic-brute-find-first-tag-by-name}
@end defun

@defun semantic-brute-find-tag-by-property property value streamorbuffer &optional search-parts search-includes
Find all tags with @var{PROPERTY} equal to @var{VALUE} in @var{STREAMORBUFFER}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-property,semantic-brute-find-tag-by-property}
@end defun

@defun semantic-brute-find-tag-by-attribute attr streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec,semantic-brute-find-tag-by-attribute}
@end defun

@defun semantic-brute-find-tag-by-attribute-value attr value streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} equal to @var{VALUE} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
@var{VALUE} is the value that @var{ATTR} should match.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec-value,semantic-brute-find-tag-by-attribute-value}
@end defun

@defun semantic-brute-find-tag-by-position position streamorbuffer &optional nomedian
Find a nonterminal covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.

@obsolete{semantic-find-nonterminal-by-position,semantic-brute-find-tag-by-position}
@end defun

@defun semantic-brute-find-innermost-tag-by-position position streamorbuffer &optional nomedian
Find a list of tags covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.
This function will find the topmost item, and recurse until no more
details are available of findable.

@obsolete{semantic-find-innermost-nonterminal-by-position,semantic-brute-find-innermost-tag-by-position}
@end defun

@defun semantic-brute-find-tag-by-class class streamorbuffer &optional search-parts search-includes
Find all tags with a class @var{CLASS} within @var{STREAMORBUFFER}.
@var{CLASS} is a symbol representing the class of the tags to find.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

Use @code{semantic-find-tag-by-class} instead.

@obsolete{semantic-find-nonterminal-by-token,semantic-brute-find-tag-by-class}
@end defun

@defun semantic-brute-find-tag-standard streamorbuffer &optional search-parts search-includes
Find all tags in @var{STREAMORBUFFER} which define simple class types.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-standard,semantic-brute-find-tag-standard}
@end defun

@defun semantic-brute-find-tag-by-type type streamorbuffer &optional search-parts search-includes
Find all tags with type @var{TYPE} within @var{STREAMORBUFFER}.
@var{TYPE} is a string which is the name of the type of the tags returned.
See @dfn{semantic-tag-type}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-type,semantic-brute-find-tag-by-type}
@end defun

@defun semantic-brute-find-tag-by-function function streamorbuffer &optional search-parts search-includes
Find all tags for which FUNCTION's value is non-@code{nil} within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

If optional argument @var{SEARCH-PARTS} is non-@code{nil}, all sub-parts of tags
are searched.  The overloadable function @code{semantic-tag-componenets} is
used for the searching child lists.  If @var{SEARCH-PARTS} is the symbol
@code{'positiononly}, then only children that have positional information are
searched.

If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.  This parameter hasn't be active for a while
and is obsolete.

@obsolete{semantic-find-nonterminal-by-function,semantic-brute-find-tag-by-function}
@end defun

@defun semantic-brute-find-first-tag-by-function function streamorbuffer &optional search-parts search-includes
Find the first nonterminal which @var{FUNCTION} match within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

The following parameters were never implemented.

If optional argument @var{SEARCH-PARTS}, all sub-parts of tags are searched.
The overloadable function @dfn{semantic-tag-components} is used for
searching.
If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.

@obsolete{semantic-find-nonterminal-by-function-first-match,semantic-brute-find-first-tag-by-function}
@end defun

@c @defun semantic-recursive-find-nonterminal-by-name name buffer
@c Recursivly find the first occurance of @var{NAME}.
@c Start search with @var{BUFFER}.  Recurse through all dependencies till
@c found.  The return item is of the form (@var{BUFFER} @var{TOKEN})
@c where @var{BUFFER} is the buffer in which @var{TOKEN} (the token found
@c to match @var{NAME}) was found.
@c 
@c @var{THIS} ISN'T @var{USED} @var{IN} @var{SEMANTIC}.  @var{DELETE}
@c @var{ME} @var{SOON}.
@c @end defun

@node Tags at Point
@section Tags at Point

When you need to get the tag the cursor is on, there is a more
efficient mechanism than using
@code{semantic-brute-find-tag-by-position}.  This mechanism directly
queries the overlays the parsing step leaves in the buffer.  This
provides for very rapid retrieval of what function or variable the
cursor is currently in.
@refill

These functions query the current buffer's overlay system for tags.

@defun semantic-find-tag-by-overlay &optional positionormarker buffer
Find all tags covering @var{POSITIONORMARKER} by using overlays.
If @var{POSITIONORMARKER} is @code{nil}, use the current point.
Optional @var{BUFFER} is used if @var{POSITIONORMARKER} is a number, otherwise the current
buffer is used.  This finds all tags covering the specified position
by checking for all overlays covering the current spot.  They are then sorted
from largest to smallest via the start location.

@obsolete{semantic-find-nonterminal-by-overlay,semantic-find-tag-by-overlay}
@end defun

@defun semantic-find-tag-by-overlay-in-region start end &optional buffer
Find all tags which exist in whole or in part between @var{START} and @var{END}.
Uses overlays to determine positin.
Optional @var{BUFFER} argument specifies the buffer to use.

@obsolete{semantic-find-nonterminal-by-overlay-in-region,semantic-find-tag-by-overlay-in-region}
@end defun

@defun semantic-find-tag-by-overlay-next &optional start buffer
Find the next tag after @var{START} in @var{BUFFER}.
If @var{START} is in an overlay, find the tag which starts next,
not the current tag.
@end defun

@defun semantic-find-tag-by-overlay-prev &optional start buffer
Find the next tag before @var{START} in @var{BUFFER}.
If @var{START} is in an overlay, find the tag which starts next,
not the current tag.
@end defun

@defun semantic-current-tag
Return the current tag in the current buffer.
If there are more than one in the same location, return the
smallest tag.  Return @code{nil} if there is no tag here.

@obsolete{semantic-current-nonterminal,semantic-current-tag}
@end defun

@defun semantic-current-tag-parent
Return the current tags parent in the current buffer.
@var{A} tag's parent would be a containing structure, such as a type
containing a field.  Return @code{nil} if there is no parent.

@obsolete{semantic-current-nonterminal-parent,semantic-current-tag-parent}
@end defun

@node Tag Sorting
@section Tag Sorting

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the
tag list for you.

@defun semantic-bucketize tags &optional parent filter
Sort @var{TAGS} into a group of buckets based on tag class.
Unknown classes are placed in a Misc bucket.
Type bucket names are defined by either `semantic-symbol->name-assoc-list'.
If @var{PARENT} is specified, then @var{TAGS} belong to this @var{PARENT} in some way.
This will use `semantic-symbol->name-assoc-list-for-type-parts' to
generate bucket names.
Optional argument @var{FILTER} is a filter function to be applied to each bucket.
The filter function will take one argument, which is a list of tags, and
may re-organize the list with side-effects.
@end defun

@defvar semantic-bucketize-tag-class
Function used to get a symbol describing the class of a token.
This function must take one argument of a semantic token.
It should return a symbol found in `semantic-symbol->name-assoc-list'
which @dfn{semantic-bucketize} uses to bin up tokens.
To create new bins for an application augment
`semantic-symbol->name-assoc-list', and
`semantic-symbol->name-assoc-list-for-type-parts' in addition
to setting this variable (locally in your function).
@end defvar

@defun semantic-adopt-external-members tags
Rebuild @var{TAGS} so that externally defined members are regrouped.
Some languages such as @var{C}++ and @var{CLOS} permit the declaration of member
functions outside the definition of the class.  It is easier to study
the structure of a program when such methods are grouped together
more logically.

This function uses @dfn{semantic-nonterminal-external-member-p} to
determine when a potential child is an externally defined member.

Note: Applications which use this function must account for tag
types which do not have a position, but have children which *do*
have positions.

Applications should use @code{semantic-mark-external-member-function}
to modify all tags which are found as externally defined to some
type.  For example, changing the tag type for generating extra
buckets with the bucket function.
@end defun

@defvar semantic-orphaned-member-metaparent-type
In @dfn{semantic-adopt-external-members}, the type of @code{'type} for metaparents.
@var{A} metaparent is a made-up type semantic tag used to hold the child list
of orphaned members of a named type.
@end defvar

@defvar semantic-mark-external-member-function
Function called when an externally defined orphan is found.
Be default, the tag is always marked with the @code{adopted} property.
This function should be locally bound by a program that needs
to add additional behaviors into the tag list.
This function is called with one argument which is a shallow copy
of the tag to be modified.  This function should return the
tag (or a copy of it) which is then integrated into the
revised tag list.
@end defvar

@node Tag Completion
@section Tag Completion

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time,
the semantics can be quite complex.  If two tags have the same name,
which do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the @dfn{interactive} command like this:

@example
(defun my-function (tag)
   "Do something to TAG."
   (interactive (list (my-completion-function "Tag: ")))
   ...)
@end example

@menu
* Tag Completion Convenience Functions:: Provided functions
* Custom Tag Completion Functions:: Build your own completion function
* Old Tag Completion::          Completion functions from older releases
@end menu

@node Tag Completion Convenience Functions
@subsection Tag Completion Convenience Functions

There are some pre written completion functions that can be used in your
programs.

@defun semantic-complete-read-tag-buffer-deep prompt &optional default-tag initial-input history
Ask for a tag by name from the current buffer.
Available tags are from the current buffer, at any level.
Completion options are presented in a traditional way, with highlighting
to resolve same-name collisions.
@var{PROMPT} is a string to prompt with.
@var{DEFAULT-TAG} is a semantic tag or string to use as the default value.
If @var{INITIAL-INPUT} is non-@code{nil}, insert it in the minibuffer initially.
@var{HISTORY} is a symbol representing a variable to story the history in.
@end defun

@node Custom Tag Completion Functions
@subsection Custom Tag Completion Functions

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

@table @asis
@item Tag Collection
Something that selects tags, and provides some list of tags
available, such as all functions, or all classes named ``bob''.
@item Typing and selecting
The prompt where you can type in the name of a tag.
@item Displaying possible completion values
A mechanism for displaying completion lists.
@end table

There is one typing and selecting routine that can be used to create
your custom completion prompt.

@defun semantic-complete-read-tag-engine collector displayor prompt default-tag initial-input history
Read a semantic tag, and return a tag for the selection.
Argument @var{COLLECTOR} is a function which can be used to to return
a list of possible hits.  See @code{semantic-completion-collector-engine}
for details on @var{COLLECTOR}.
Argumeng @var{DISPLAYOR} is a function used to display a list of possible
completions for a given prefix.  See@code{semantic-completion-display-engine}
for details on @var{DISPLAYOR}.
@var{PROMPT} is a string to prompt with.
@var{DEFAULT-TAG} is a semantic tag or string to use as the default value.
If @var{INITIAL-INPUT} is non-@code{nil}, insert it in the minibuffer initially.
@var{HISTORY} is a symbol representing a variable to story the history in.
@end defun

As you can see, this takes one @dfn{collector}, and one
@dfn{displayor}.  These are objects created for this prompt at
runtime.  The completion engine then uses to perform their tasks.

For example:

@example
(defun semantic-complete-read-tag-buffer-deep (prompt &optional
						      default-tag initial-input history)
  "Ask for a tag by name from the current buffer.
PROMPT is a string to prompt with.
DEFAULT-TAG is a semantic tag or string to use as the default value.
If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
HISTORY is a symbol representing a variable to story the history in."
  (semantic-complete-read-tag-engine
   (semantic-collector-buffer-deep prompt :buffer (current-buffer))
   (semantic-displayor-traditional-with-focus-highlight "simple")
   ;;(semantic-displayor-tooltip "simple")
   prompt
   default-tag
   initial-input
   history)
  )
@end example

@menu
* Tag Collectors::
* Tag Displayors::
@end menu

@node Tag Collectors
@subsubsection Tag Collectors

A tag collector is an object that inherits from
@dfn{semantic-collector-abstract}.  A new collector is needed for
each specialized type of prompt that draws from a different selection
of tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

All collectors inherit from:

@deffn Type semantic-collector-abstract
Root class for completion engines.
@end deffn

Available instantiable classes are:

@deffn Type semantic-collector-buffer-deep
Completion engine for tags in the current buffer.
Provides deep searches through types.
@end deffn

NOTE: Add sections for writing new collectors.

@c (eieiodoc-class semantic-collector-abstract "cc")

@c END OF COLLECTOR

@node Tag Displayors
@subsubsection Tag Displayors

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to @b{focus} one one particular
tag of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

@deffn Type semantic-displayor-abstract
Manages the display of some number of tags.
@end deffn

Distinct implementations of displayors include:

@deffn Type semantic-displayor-traditional
Traditional display mechanism for a list of possible completions.
@end deffn

@deffn Type semantic-displayor-traditional-with-focus-highlight
A traditional displayor which can focus on a tag by showing it.
@end deffn

@deffn Type semantic-displayor-tooltip
Display mechanism using tooltip for a list of possible completions.
@end deffn

NOTE: Add sections for writing new collectors.

@c (eieiodoc-class semantic-displayor-abstract "cd")

@c END OF DISPLAYOR


@node Old Tag Completion
@subsection Older Tag Completion functions

These are older completion functions.  They may still be useful.

@defun semantic-read-symbol prompt &optional default stream filter
Read a symbol name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@var{FILTER} is provides a filter on the types of things to complete.
@var{FILTER} must be a function to call on each element.  (See !!!
@end defun

@defun semantic-read-variable prompt &optional default stream
Read a variable name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@defun semantic-read-function prompt &optional default stream
Read a function name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@defun semantic-read-type prompt &optional default stream
Read a type name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@node Override Methods
@section Override Methods

These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

@menu
* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Local Context::               Deriving information about a language specific local context.
* Making New Methods::          How to add your own methods for a tool
@end menu

@node Format Tag
@subsection Format Tag

Any given tag consists of Meta information which is best viewed in
some textual form.  This could be as simple as the tag's name, or as
a prototype to be added to header file in C.  Not only are there
several default converters from a Tag into text, but there is also
some convenient variables that can be used with them.  Use these
variables to allow options on output forms when displaying tags in
your programs.

@defvar semantic-format-tag-functions
List of functions which convert a tag to text.
Each function must take the parameters @var{TAG} &optional @var{PARENT} @var{COLOR}.
@var{TAG} is the tag to convert.
@var{PARENT} is a parent tag or name which refers to the structure
or class which contains @var{TAG}.  @var{PARENT} is @var{NOT} a class which a @var{TAG}
would claim as a parent.
@var{COLOR} indicates that the generated text should be colored using
@code{font-lock}.
@end defvar

@defvar semantic-format-tag-custom-list
@var{A} List used by customizeable variables to choose a tag to text function.
Use this variable in the @code{:type} field of a customizable variable.
@end defvar

Every tag to text conversion function must take the same parameters,
which are @var{TAG}, the tag to be converted, @var{PARENT}, the
containing parent (like a structure which contains a variable), and
@var{COLOR}, which is a flag specifying that color should be applied
to the returned string.

When creating, or using these strings, particularly with color, use
@dfn{concat} to build up larger strings instead of @dfn{format}.  This
will preserve text properties.

@defun semantic-format-tag-name tag &optional parent color
Return the name string describing @var{TAG}.
The name is the shortest possible representation.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-abbreviate tag &optional parent color
Return an abbreviated string describing @var{TAG}.
The abbreviation is to be short, with possible symbols indicating
the type of tag, or other information.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-summarize tag &optional parent color
Summarize @var{TAG} in a reasonable way.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-prototype tag &optional parent color
Return a prototype for @var{TAG}.
This function should be overloaded, though it need not be used.
This is because it can be used to create code by language independent
tools.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-concise-prototype tag &optional parent color
Return a concise prototype for @var{TAG}.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-uml-abbreviate tag &optional parent color
Return a @var{UML} style abbreviation for @var{TAG}.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-uml-prototype tag &optional parent color
Return a @var{UML} style prototype for @var{TAG}.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-uml-concise-prototype tag &optional parent color
Return a @var{UML} style concise prototype for @var{TAG}.
Optional argument @var{PARENT} is the parent type if @var{TAG} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-format-tag-prin1 tag &optional parent color
Convert @var{TAG} to a string that is the print name for @var{TAG}.
@var{PARENT} and @var{COLOR} are ignored.
@end defun

@node Tag Members
@subsection Tag Members

Tags are often in a hierarchical form, meaning that a tag found in
the top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

@defun semantic-tag-components tag
Return a list of components for @var{TAG}.
A Component is a part of @var{TAG} which itself may be a @var{TAG}.
Examples include the elements of a structure in a @code{`type} tag,
or the list of arguments to a @code{'function} tag.
@end defun

@defun semantic-tag-components-with-overlays tag
Return the list of top level components belonging to @var{TAG}.
Children are any sub-tags which contain overlays.

Default behavior is to get @dfn{semantic-tag-components} in addition
to the components of an anonymous types (if applicable.)

Note for language authors:
  If a mode defines a language tag that has tags in it with overlays
you should still return them with this function.
Ignoring this step will prevent several features from working correctly.
@end defun

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.


@defun semantic-tag-external-member-p parent token
Return non-@code{nil} if @var{PARENT} is the parent of @var{TAG}.
@var{TAG} is an external member of @var{PARENT} when it is somehow tagged
as having @var{PARENT} as it's parent.
@var{PARENT} and @var{TAG} must both be semantic tags.

The default behavior, if not overridden with
@code{tag-external-member-p} is to match @code{'parent} extra specifier in
the name of @var{TAG}.

If this function is overridden, use
@code{semantic-tag-external-member-children-p-default} to also
include the default behavior, and merely extend your own.
@end defun

@defun semantic-tag-external-member-children tag &optional usedb
Return the list of children which are not *in* @var{TAG}.
If optional argument @var{USEDB} is non-@code{nil}, then also search files in
the Semantic Database.  If @var{USEDB} is a list of databases, search those
databases.

Children in this case are functions or types which are members of
@var{TAG}, such as the parts of a type, but which are not defined inside
the class.  @var{C}++ and @var{CLOS} both permit methods of a class to be defined
outside the bounds of the class' definition.

The default behavior, if not overridden with
@code{tag-external-member-children} is to search using
@dfn{semantic-tag-external-member-p} in all top level definitions
with a parent of @var{TAG}.

If this function is overridden, use
@dfn{semantic-tag-external-member-children-default} to also
include the default behavior, and merely extend your own.
@end defun

@node Tag Details
@subsection Tag Details

These functions help derive information about tags that may not
be obvious for non-traditional languages with their own token types.

@defun semantic-tag-protection tag &optional parent
Return protection information about @var{TAG} with optional @var{PARENT}.
This function returns on of the following symbols:
   @code{nil}        - No special protection.  Language dependent.
   @code{'public}    - Anyone can access this @var{TAG}.
   @code{'private}   - Only methods in the local scope can access @var{TAG}.
   @code{'protected} - Like private for outside scopes, like public for child
                classes.
Some languages may choose to provide additional return symbols specific
to themselves.  Use of this function should allow for this.

The default behavior (if not overridden with @code{tag-protection}
is to return a symbol based on type modifiers.
@end defun

@defun semantic-tag-abstract tag &optional parent
Return non @code{nil} if @var{TAG} is abstract.
Optional @var{PARENT} is the parent tag of @var{TAG}.
In @var{UML}, abstract methods and classes have special meaning and behavior
in how methods are overridden.  In @var{UML}, abstract methods are italicized.

The default behavior (if not overridden with @code{tag-abstract}
is to return true if @code{abstract} is in the type modifiers.
@end defun

@defun semantic-tag-leaf tag &optional parent
Return non @code{nil} if @var{TAG} is leaf.
Optional @var{PARENT} is the parent tag of @var{TAG}.
In @var{UML}, leaf methods and classes have special meaning and behavior.

The default behavior (if not overridden with @code{tag-leaf}
is to return true if @code{leaf} is in the type modifiers.
@end defun

@defun semantic-tag-static tag &optional parent
Return non @code{nil} if @var{TAG} is static.
Optional @var{PARENT} is the parent tag of @var{TAG}.
In @var{UML}, static methods and attributes mean that they are allocated
in the parent class, and are not instance specific.
@var{UML} notation specifies that @var{STATIC} entries are underlined.
@end defun

@defvar semantic-dependency-include-path
Defines the include path used when searching for files.
This should be a list of directories to search which is specific to
the file being included.
If @code{semantic-find-dependency} is overridden for a given language, this
path is most likely ignored.

@var{TODO}: use ffap.el to locate such items.
@end defvar

@defun semantic-dependency-tag-file &optional tag
Find the filename represented from @var{TAG}.
Depends on @code{semantic-dependency-include-path} for searching.  Always searches
@code{.} first, then searches additional paths.
@end defun

@defun semantic-prototype-file buffer
Return a file in which prototypes belonging to @var{BUFFER} should be placed.
Default behavior (if not overridden) looks for a token specifying the
prototype file, or the existence of an @var{EDE} variable indicating which
file prototypes belong in.
@end defun

@defun semantic-go-to-tag &optional tag parent
Go to the location of @var{TAG}.
@var{TAG} may be a stripped element, in which case @var{PARENT} specifies a
parent tag that has position information.
Different behaviors are provided depending on the type of tag.
For example, dependencies (includes) will seek out the file that is
depended on (see @dfn{semantic-dependency-tag-file}..
@end defun

@defun semantic-texi-find-documentation name &optional type
Find the function or variable @var{NAME} of @var{TYPE} in the texinfo source.
@var{NAME} is a string representing some functional symbol.
@var{TYPE} is a string, such as ``variable`` or ''Command'' used to find
the correct definition in case @var{NAME} qualifies as several things.
When this function exists, @var{POINT} is at the definition.
If the doc was not found, an error is thrown.
Note: @var{TYPE} not yet implemented.
@end defun

@node Local Context
@subsection Local Context

@defun semantic-up-context &optional point bounds-type
Move point up one context from @var{POINT}.
Return non-@code{nil} if there are no more context levels.
Overloaded functions using @code{up-context} take no parameters.
@var{BOUNDS-TYPE} is a symbol representing a tag class to restrict
movement to.  If this is @code{nil}, @code{'function} is used.
This will find the smallest tag of that class (function, variable,
type, etc) and make sure non-@code{nil} is returned if you cannot
go up past the bounds of that tag.
@end defun

@defun semantic-beginning-of-context &optional point
Move @var{POINT} to the beginning of the current context.
Return non-@code{nil} if there is no upper context.
The default behavior uses @dfn{semantic-up-context}.
This function can be overriden in semantic using the
symbol @code{beginning-of-context}.
@end defun

@defun semantic-end-of-context &optional point
Move @var{POINT} to the end of the current context.
Return non-@code{nil} if there is no upper context.
Be default, this uses @dfn{semantic-up-context}, and assumes parenthetical
block delimiters.
This function can be overriden in semantic using the
symbol @code{end-of-context}.
@end defun

@defun semantic-get-local-variables &optional point
Get the local variables based on POINT's context.
Local variables are returned in Semantic tag format.
Be default, this calculates the current bounds using context blocks
navigation, then uses the parser with @code{bovine-inner-scope} to
parse tags at the beginning of the context.
This can be overriden with @code{get-local-variables}.
@end defun

@defun semantic-get-local-arguments &optional point
Get arguments (variables) from the current context at @var{POINT}.
Parameters are available if the point is in a function or method.
Return a list of tags unlinked from the originating buffer.
Arguments are obtained by overriding @code{get-local-arguments}, or by the
default function @dfn{semantic-get-local-arguments-default}.  This, must
return a list of tags, or a list of strings that will be converted to
tags.
@end defun

@defun semantic-get-all-local-variables &optional point
Get all local variables for this context, and parent contexts.
Local variables are returned in Semantic tag format.
Be default, this gets local variables, and local arguments.
Optional argument @var{POINT} is the location to start getting the variables from.
This function can be overriden in semantic using the
symbol @code{get-all-local-variables}.
@end defun

These next set of functions handle local context parsing.   This means
looking at the code (locally) and navigating, and fetching information
such as a the type of the parameter the cursor may be typing in.

@defun semantic-end-of-command
Move to the end of the current command.
Be default, uses @code{semantic-command-separation-character}.
This function can be overriden in semantic using the
symbol @code{end-of-command}.
@end defun

@defun semantic-beginning-of-command
Move to the beginning of the current command.
Be default, uses @code{semantic-command-separation-character}.
This function can be overriden in semantic using the
symbol @code{beginning-of-command}.
@end defun

@defun semantic-ctxt-current-symbol &optional point
Return the current symbol the cursor is on at @var{POINT} in a list.
This will include a list of type/field names when applicable.
This function can be overriden in semantic using the
symbol @code{ctxt-current-symbol}.
@end defun

@defun semantic-ctxt-current-assignment &optional point
Return the current assignment near the cursor at @var{POINT}.
Return a list as per @dfn{semantic-ctxt-current-symbol}.
Return @code{nil} if there is nothing relevant.
This function can be overriden in semantic using the
symbol @code{ctxt-current-assignment}.
@end defun

@defun semantic-ctxt-current-function &optional point
Return the current function call the cursor is in at @var{POINT}.
The function returned is the one accepting the arguments that
the cursor is currently in.  It will not return function symbol if the
cursor is on the text representing that function.
This function can be overriden in semantic using the
symbol @code{ctxt-current-function}.
@end defun

@defun semantic-ctxt-current-argument &optional point
Return the index of the argument position the cursor is on at @var{POINT}.
This function can be overriden in semantic using the
symbol @code{ctxt-current-argument}.
@end defun

@defun semantic-ctxt-scoped-types &optional point
Return a list of type names currently in scope at @var{POINT}.
This function can be overriden in semantic using the
symbol @code{ctxt-scoped-types}.
@end defun

For details on using these functions to get more detailed information
about the current context: @xref{Context Analysis}.

@node Making New Methods
@subsection Making New Methods

@node Parser Hooks
@section Parser Hooks

If you write a program that uses a tag table in a persistent
display or database, it is necessary to know when tag tables change so
that your displays can be updated.  This is especially important as
tags can be replaced, changed, or deleted, and the associated
overlays will then throw errors when you try to use them.  Complete
integration with tag changes can be achieved via several hooks.

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

@defvar semantic-edits-are-safe
When non-@code{nil}, modifications do not require a reparse.
This prevents tokens from being marked dirty, and it
prevents top level edits from causing a cache check.
Use this when writing programs that could cause a full
reparse, but will not change the tag structure, such
as adding or updating top-level comments.
@end defvar

Next, it is sometimes useful to know what the current parsing state
is.  These function can let you know what level of re-parsing may be
needed.  Careful choices on when to reparse can make your program much
faster.

@c PARSER STATE STUFF HERE

@defun semantic-parse-tree-needs-update-p
Return non-@code{nil} if the current parse tree needs to be updated.
@end defun

@defun semantic-parse-tree-needs-rebuild-p
Return non-@code{nil} if the current parse tree needs to be rebuilt.
@end defun

@defun semantic-parse-tree-up-to-date-p
Return non-@code{nil} if the current parse tree is up to date.
@end defun

If you just want to know when a buffer changes, use this hook.

@defvar semantic-after-toplevel-cache-change-hook
Hooks run after the buffer token list has changed.
This list will change when a buffer is reparsed, or when the token
list in a buffer is cleared.  It is *@var{NOT}* called if the current token
list partially reparsed.

Hook functions must take one argument, which is the new list of
tokens associated with this buffer.

For language specific hooks, make sure you define this as a local hook.
@end defvar

If you want tighter interaction with how the user is editing
different tags, you can use this hook instead.

@defvar semantic-after-partial-cache-change-hook
Hooks run after the buffer cache has been updated.

This hook will run when the cache has been partially reparsed.
Partial reparses are incurred when a user edits a buffer, and only the
modified sections are rescanned.

Hook functions must take one argument, which is the list of tokens
updated in the current buffer.

For language specific hooks, make sure you define this as a local hook.
@end defvar

@defvar semantic-before-toplevel-cache-flush-hook
Hooks run before the toplevel nonterminal cache is flushed.
For language specific hooks, make sure you define this as a local
hook.  This hook is called before a corresponding
@code{semantic-after-toplevel-cache-change-hook} which is also called
during a flush when the cache is given a new value of nil.
@end defvar

@node Semantic Database
@section Semantic Database

@menu
* Semanticdb in Programs::
* Semanticdb Tag Queries::
@end menu

@node Semanticdb in Programs
@subsection Semanticdb in Programs::

If you write a program using semanticdb, you will probably want to
make sure it is active in your program.

@defun semanticdb-minor-mode-p
Return non-@code{nil} if @code{semanticdb-minor-mode} is active.
@end defun


@node Semanticdb Tag Queries
@subsection Semanticdb Tag Queries

You can search for tokens in the database using the following
functions.  It is important to note that database search functions do
not return a plain list of tokens.  This is because some tokens may
not be loaded in a buffer, which means that the found token would not
have an overlay, and no way to determine where it came from.

As such, all search functions return a list of the form:

@example
   ( (DATABASE TOKEN1 TOKEN2 ...) (DATABASE2 TOKEN3 TOKEN4 ...) ...)
@end example

@defun semanticdb-file-stream file
Return a list of tokens belonging to @var{FILE}.
If file has database tokens available in the database, return them.
If file does not have tokens available, then load the file, and create them.
@end defun

@node Example Programs
@section Programming Examples

Here are some simple examples that use different aspects of the
semantic library APIs.  For fully functional example programs with
lots of comments, see the file @file{semantic-examples.el}.

@heading Interactively querying for a token name

If you need a command that asks the user for a token name, you can
get full range completion using the query functions
@ref{Tag Completion}.

@example
(interactive (list (semantic-read-symbol "Symbol: ")))
@end example

@heading Finding a symbol in a buffer

If you have the name of a function or variable, and need to find its
location in a buffer, you need a search function.  There is a wide
range of searches you can perform @ref{Tag Tables}.

@example
(semantic-find-nonterminal-by-name
 "some-name"
 (current-buffer)
 t    ;; look inside structures and classes for these symbols
 nil) ;; do not look inside header files.
@end example

@heading Finding a symbol in a project

If you have the name of a function or variable, and need to find its
location somewhere in a project, you need to use the Semantic Database
@ref{semanticdb}.  There are many search functions similar to the
ones found in @ref{Tag Tables}.

The Semantic Database is interesting in that the return structure is
not

@heading Locating a token in a buffer

If you have a nonterminal token, or a list of them, you may want to
find their position in a buffer.

@example
(semanticdb-find-nonterminal-by-name
 "symbol"
 nil   ;; Defaults to the current project's database list.
 t     ;; Search inside types
 nil   ;; Do not search include files
 nil   ;; Only search files in the same mode (all C files)
 t     ;; When a token is found, make sure it is loaded in a buffer.
 )
@end example

Of interesting note above, semanticdb can find symbols in files that
are not loaded into an Emacs buffer.  These tokens do not have an
associated overlay, and the function @dfn{semantic-token-buffer} will
fail.

The last parameter's tells the search function to
@dfn{find-file-noselect} any file in which a matching token was
found.  This will allow you to merge all the tokens into a completion
list, or other flat list needed by most functions that use
association lists.

If you do not ask semanticdb to load those files, you will need to
explicitly request the database object (found in the @code{car} of
each sublist) get the file loaded.  It is useful to not auto find all
files if you don't need to jump to that token.

@heading Converting a token into a human readable string.

A tag is a rather unpleasant Lisp structure when trying
to decipher what is going on.  As such, there is a wide range of
functions available that can convert a token into a human readable,
and colorful string @ref{Format Tag}.

If you program interfaces with lots of users, you will probably want
to have your program define a configurable variable that will let
users change the visible portion of your program.

@example
(defcustom my-summary-function 'semantic-uml-prototype-nonterminal
  "*Function to use when showing info about my tag."
  :group 'my-program
  :type semantic-format-tag-custom-list)
@end example

Note the special type provided by Semantic.

Next, you can call this function to create a string.

@example
(funcall my-summary-function tag
                             tag-parent
                             t ; use color
                             )
@end example

In this case, @var{tag-parent} is an optional argument.  In many
cases, parent is not used by the outputting function.  The parent must
be a tag whose @code{semantic-tag-componenets} contains @var{tag}, or
nil for top-level definitions.  In particular, C++ needs the parent to
correctly calculate the protection of each method.


@node Current Context
@section Deriving the Current Context

This chapter deals with how to derive the current context, and also
how a language maintainer can get the current context API to work
with their language.

By default, the behavior will function in C like languages.  This
means languages with parenthetical blocks, and type dereferencing
which uses a similar form.

@menu
* Blocks::                      
* Local Variables::             Getting lists of local variables.
* Derived Context::             What goes at a given location?
* Context Analysis::            Analysis information about the local context.
@end menu

@node Blocks
@subsection Blocks and Navigation

Source code is typically built up of control structures, and blocks of
context, or lexical scope.  Semantic terms these lexical scopes as a
``context''.  The following functions can be used to navigate contexts.
Some of them are override functions.  Language authors can override
a subset of them to make them work for their language.

@defun semantic-up-context &optional point
Move point up one context from @var{POINT}.
Return non-@code{nil} if there are no more context levels.
Overloaded functions using @code{up-context} take no parameters.
@end defun

@defun semantic-beginning-of-context &optional point
Move @var{POINT} to the beginning of the current context.
Return non-@code{nil} if there is no upper context.
The default behavior uses @code{semantic-up-context}.  It can
be overridden with @code{beginning-of-context}.
@end defun

@defun semantic-end-of-context &optional point
Move @var{POINT} to the end of the current context.
Return non-@code{nil} if there is no upper context.
Be default, this uses @code{semantic-up-context}, and assumes parenthetical
block delimiters.  This can be overridden with @code{end-of-context}.
@end defun

These next set of functions can be used to navigate across commands.

@defun semantic-end-of-command
Move to the end of the current command.
Be default, uses @code{semantic-command-separation-character}.
Override with @code{end-of-command}.
@end defun

@defun semantic-beginning-of-command
Move to the beginning of the current command.
Be default, users @code{semantic-command-separation-character}.
Override with @code{beginning-of-command}.
@end defun

@node Local Variables
@subsection Deriving local variables

Within a given context, or block of code, local variables are often
defined.  These functions can be used to retrieve lists of locally
scoped variables.

@defun semantic-get-local-variables &optional point
Get the local variables based on POINT's context.
Local variables are returned in Semantic token format.
By default, this calculates the current bounds using context blocks
navigation, then uses the parser with @code{bovine-inner-scope} to
parse tokens at the beginning of the context.
This can be overridden with @code{get-local-variables}.
@end defun

@defun semantic-get-local-arguments &optional point
Get arguments (variables) from the current context at @var{POINT}.
Parameters are available if the point is in a function or method.
This function returns a list of tokens.  If the local token returns
just a list of strings, then this function will convert them to tokens.
Part of this behavior can be overridden with @code{get-local-arguments}.
@end defun

@defun semantic-get-all-local-variables &optional point
Get all local variables for this context, and parent contexts.
Local variables are returned in Semantic token format.
Be default, this gets local variables, and local arguments.
This can be overridden with @code{get-all-local-variables}.
Optional argument @var{POINT} is the location to start getting the variables from.
@end defun

@node Derived Context
@subsection Deriving the Current Context

While a context has already been used to describe blocks of code,
other context include more local details, such as the symbol the
cursor is on, or the fact we are assigning into some other variable.

These context deriving functions can be overridden to provide language
specific behavior.  By default, it assumes a C like language.

@defun semantic-ctxt-current-symbol &optional point
Return the current symbol the cursor is on at @var{POINT} in a list.
This will include a list of type/field names when applicable.
This can be overridden using @code{ctxt-current-symbol}.
@end defun

@defun semantic-ctxt-current-assignment &optional point
Return the current assignment near the cursor at @var{POINT}.
Return a list as per @code{semantic-ctxt-current-symbol}.
Return @code{nil} if there is nothing relevant.
Override with @code{ctxt-current-assignment}.
@end defun

@defun semantic-ctxt-current-function &optional point
Return the current symbol the cursor is on at @var{POINT}.
The function returned is the one accepting the arguments that
the cursor is currently in.
This can be overridden with `ctxt.current-function'.
@end defun

@defun semantic-ctxt-current-argument &optional point
Return the current symbol the cursor is on at @var{POINT}.
Override with @code{ctxt-current-argument}.
@end defun

@node Context Analysis
@subsection Analysis of the current context

The context parsing API is used in a context analysis library.  This
library provides high level routines for scanning through token
databases to create lists of token associates.  At it's core is a set
of EIEIO classes defining a context.  The context contains information
about what was parsed at a given position, such as the strings there,
and they type of assignment.  The analysis library then searches the
databases to determine the types and names available.

Two high level functions which can be run interactively are:

*NOTE TO SELF: Add more here*

@deffn Command semantic-analyze-current-context position
Analyze the current context at @var{POSITION}.
If called interactively, display interesting information about @var{POSITION}
in a separate buffer.
Returns an object based on symbol @code{semantic-analyze-context}.
@end deffn


@deffn Command semantic-analyze-possible-completions point
Return a list of semantic tokens which are possible completions.
Analysis is done at @var{POINT}.
@end deffn
