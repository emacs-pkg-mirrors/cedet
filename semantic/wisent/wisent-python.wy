;;; wisent-python.wy -- LALR grammar for Python
;;
;; Copyright (C) 2002 Richard Kim
;;
;; Author: Richard Kim <ryk@dspwiz.com>
;; Maintainer: Richard Kim <ryk@dspwiz.com>
;; Created: June 2002
;; Keywords: syntax
;; X-RCS: $Id: wisent-python.wy,v 1.18 2003/01/25 06:13:44 emacsman Exp $
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:
;;
;; See comments in wisent-python.el.

;; --------
;; Settings
;; --------
%{
  (setq
   ;; Character used to separation a parent/child relationship
   semantic-type-relation-separator-character '(".")
   semantic-command-separation-character ";"
   ;; Init indentation stack
   wisent-python-lexer-indent-stack '(0)

   semantic-lex-analyzer #'semantic-python-lexer
   semantic-lex-depth	0
   )

  %}

%outputfile    "wisent-python.el"
%parsetable    wisent-python-parser-tables
%keywordtable  wisent-python-keywords
%tokentable    wisent-python-tokens
%languagemode  python-mode
%setupfunction wisent-python-default-setup

%start	       goal

;; Customize `wisent-flex' match algorithm
;; - Use string comparison for:
;; %put {open-paren close-paren symbol} string t

;; Customize `wisent-flex' match algorithm
;; - Use string comparison for:
;; - An operator can be made of multiple successive punctuations
;; %put punctuation {string t multiple t}

%token <newline>     NEWLINE

;; ---------------------
;; Parenthesis terminals
;; ---------------------
%token <open-paren>  LPAREN 	"("
%token <close-paren> RPAREN 	")"
%token <open-paren>  LBRACE 	"{"
%token <close-paren> RBRACE     "}"
%token <open-paren>  LBRACK 	"["
%token <close-paren> RBRACK 	"]"

;; ---------------
;; Block terminals
;; ---------------
%token <semantic-list> PAREN_BLOCK     "^("
%token <semantic-list> BRACE_BLOCK     "^{"
%token <semantic-list> BRACK_BLOCK     "^\\["

;; ------------------
;; Operator terminals
;; ------------------
%token <punctuation> LTLTEQ 	"<<="
%token <punctuation> GTGTEQ 	">>="
%token <punctuation> EXPEQ	"**="
%token <punctuation> DIVDIVEQ 	"//="
%token <punctuation> DIVDIV 	"//"
%token <punctuation> LTLT 	"<<"
%token <punctuation> GTGT 	">>"
%token <punctuation> EXPONENT 	"**"
%token <punctuation> EQ 	"=="
%token <punctuation> GE 	">="
%token <punctuation> LE 	"<="
%token <punctuation> PLUSEQ 	"+="
%token <punctuation> MINUSEQ 	"-="
%token <punctuation> MULTEQ 	"*="
%token <punctuation> DIVEQ 	"/="
%token <punctuation> MODEQ 	"%="
%token <punctuation> AMPEQ 	"&="
%token <punctuation> OREQ 	"|="
%token <punctuation> HATEQ 	"^="
%token <punctuation> LTGT 	"<>"
%token <punctuation> NE 	"!="
%token <punctuation> HAT 	"^"
%token <punctuation> LT 	"<"
%token <punctuation> GT 	">"
%token <punctuation> AMP 	"&"
%token <punctuation> MULT 	"*"
%token <punctuation> DIV 	"/"
%token <punctuation> MOD 	"%"
%token <punctuation> PLUS 	"+"
%token <punctuation> MINUS 	"-"
%token <punctuation> PERIOD 	"."
%token <punctuation> TILDE 	"~"
%token <punctuation> BAR 	"|"
%token <punctuation> COLON 	":"
%token <punctuation> SEMICOLON 	";"
%token <punctuation> COMMA 	","
%token <punctuation> ASSIGN 	"="
%token <punctuation> BACKQUOTE 	"`"

%token <charquote>   BACKSLASH 	"\\"
%put charquote string t

;; -----------------
;; Literal terminals
;; -----------------
%token <string>      STRING_LITERAL
%token <number>      NUMBER_LITERAL

%token <symbol>      NAME

%token	     INDENT
%token	     DEDENT

;; -----------------
;; Keyword terminals
;; -----------------

%token AND	     "and"
%put   AND summary
"Logical AND binary operator ... "

%token ASSERT	     "assert"
%put   ASSERT summary
"Raise AssertionError exception if <expr> is false"

%token BREAK	     "break"
%put   BREAK summary
"Terminate 'for' or 'while loop"

%token CLASS	     "class"
%put   CLASS summary
"Define a new class"

%token CONTINUE	     "continue"
%put   CONTINUE summary
"Skip to the next interation of enclosing for or whilte loop"

%token DEF	     "def"
%put   DEF summary
"Define a new function"

%token DEL	     "del"
%put   DEL summary
"Delete specified objects, i.e., undo what assignment did"

%token ELIF	     "elif"
%put   ELIF summary
"Shorthand for 'else if' following an 'if' statement"

%token ELSE	     "else"
%put ELSE summary
"Start the 'else' clause following an 'if' statement"

%token EXCEPT	     "except"
%put   EXCEPT summary
"Specify exception handlers along with 'try' keyword"

%token EXEC	     "exec"
%put   EXEC summary
"Dynamically execute python code"

%token FINALLY	     "finally"
%put   FINALLY summary
"Specify code to be executed after 'try' statements whether or not an exception occured"

%token FOR	     "for"
%put   FOR summary
"Start a 'for' loop"

%token FROM	     "from"
%put   FROM summary
"Modify behavior of 'import' statement"

%token GLOBAL	     "global"
%put   GLOBAL summary
"Declare one or more symbols as global symbols"

%token IF	     "if"
%put   IF summary
"Start 'if' conditional statement"

%token IMPORT	     "import"
%put   IMPORT summary
"Load specified modules"

%token IN	     "in"
%put   IN summary
"Part of 'for' statement "

%token IS	     "is"
%put   IS summary
"Binary operator that tests for object equality"

%token LAMBDA	     "lambda"
%put   LAMDA summary
"Create anonymous function"

%token NOT	     "not"
%put   NOT summary
"Unary boolean negation operator"

%token OR	     "or"
%put   OR summary
"Binary logical 'or' operator"

%token PASS	     "pass"
%put   PASS summary
"Statement that does nothing"

%token PRINT	     "print"
%put   PRINT summary
"Print each argument to standard output"

%token RAISE	     "raise"
%put   RAISE summary
"Raise an exception"

%token RETURN	     "return"
%put RETURN summary
"Return from a function"

%token TRY	     "try"
%put   TRY summary
"Start of statements protected by exception handlers"

%token WHILE	     "while"
%put   WHILE summary
"Start a 'while' loop"

%token YIELD	     "yield"
%put   YIELD summary
"Create a generator function"

%%

;;;****************************************************************************
;;;@ goal
;;;****************************************************************************

# simple_stmt are statements that do not involve INDENT tokens
# compound_stmt are statements that involve INDENT tokens
goal
  : NEWLINE
  | simple_stmt
  | compound_stmt NEWLINE
    (identity $1)
  ;

;;;****************************************************************************
;;;@ simple_stmt
;;;****************************************************************************

;; simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
simple_stmt
  : small_stmt_list semicolon_opt NEWLINE
    (identity $1)
  ;

;; small_stmt (';' small_stmt)*
small_stmt_list
  : small_stmt
  | small_stmt_list SEMICOLON small_stmt
    (identity $1)
  ;

small_stmt
  : expr_stmt
  | print_stmt
  | del_stmt
  | pass_stmt
  | flow_stmt
  | import_stmt
  | global_stmt
  | exec_stmt
  | assert_stmt
  ;

;;;============================================================================
;;;@@ print_stmt
;;;============================================================================

;; print_stmt: 'print' [ test (',' test)* [','] ]
;;           | '>>' test [ (',' test)+ [','] ]
print_stmt
  : PRINT print_stmt_trailer
    (wisent-token $1 'code nil nil)
  ;

;; [ test (',' test)* [','] ] | '>>' test [ (',' test)+ [','] ]
print_stmt_trailer
  : test_list_opt
    (or $1 "")
  | GTGT test trailing_test_list_with_opt_comma_opt
    (identity $2)
  ;

;; [ (',' test)+ [','] ]
trailing_test_list_with_opt_comma_opt
  : ;;EMPTY
  | trailing_test_list comma_opt
    ()
  ;

;; (',' test)+
trailing_test_list
  : COMMA test
    ()
  | trailing_test_list COMMA test
    ()
  ;

;;;============================================================================
;;;@@ expr_stmt
;;;============================================================================

;; expr_stmt: testlist (augassign testlist | ('=' testlist)*)
expr_stmt
  : testlist expr_stmt_trailer
    (wisent-token "expr" 'code nil nil)
  ;

;; Could be EMPTY because of eq_testlist_zom.
;; (augassign testlist | ('=' testlist)*)
expr_stmt_trailer
  : augassign testlist
    ()
  | eq_testlist_zom
  ;

;; Could be EMPTY!
;; ('=' testlist)*
eq_testlist_zom
  : ;;EMPTY
  | eq_testlist_zom ASSIGN testlist
    ()
  ;

;; augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
;;          | '<<=' | '>>=' | '**=' | '//='
augassign
  : PLUSEQ | MINUSEQ | MULTEQ | DIVEQ | MODEQ
  | AMPEQ  | OREQ    | HATEQ  | LTLTEQ
  | GTGTEQ | EXPEQ   | DIVDIVEQ
  ;

;;;============================================================================
;;;@@ del_stmt
;;;============================================================================

;; del_stmt: 'del' exprlist
del_stmt
  : DEL exprlist
    (wisent-token $1 'code nil nil)
  ;

;; exprlist: expr (',' expr)* [',']
exprlist
  : expr_list comma_opt
    (identity $1)
  ;

;; expr (',' expr)*
expr_list
  : expr
  | expr_list COMMA expr
    (format "%s, %s" $1 $3)
  ;

;;;============================================================================
;;;@@ pass_stmt
;;;============================================================================

;; pass_stmt: 'pass'
pass_stmt
  : PASS
    (wisent-token $1 'code nil nil)
  ;

;;;============================================================================
;;;@@ flow_stmt
;;;============================================================================

flow_stmt
  : break_stmt
  | continue_stmt
  | return_stmt
  | raise_stmt
  | yield_stmt
  ;

;; break_stmt: 'break'
break_stmt
  : BREAK
    (wisent-token $1 'code nil nil)
  ;

;; continue_stmt: 'continue'
continue_stmt
  : CONTINUE
    (wisent-token $1 'code nil nil)
  ;

;; return_stmt: 'return' [testlist]
return_stmt
  : RETURN testlist_opt
    (wisent-token $1 'code nil nil)
  ;

;; [testlist]
testlist_opt
  : ;;EMPTY
  | testlist
  ;

;; yield_stmt: 'yield' testlist
yield_stmt
  : YIELD testlist
    (wisent-token $1 'code nil nil)
  ;

;; raise_stmt: 'raise' [test [',' test [',' test]]]
raise_stmt
  : RAISE zero_one_two_or_three_tests
    (wisent-token $1 'code nil nil)
  ;

;; [test [',' test [',' test]]]
zero_one_two_or_three_tests
  : ;;EMPTY
    (identity "")
  | test zero_one_or_two_tests
    (identity $1)
  ;

;; [',' test [',' test]]
zero_one_or_two_tests
  : ;;EMPTY
  | COMMA test zero_or_one_comma_test
    ()
  ;

;; [',' test]
zero_or_one_comma_test
  : ;;EMPTY
  | COMMA test
    ()
  ;

;;;============================================================================
;;;@@ import_stmt
;;;============================================================================

;; import_stmt : 'import' dotted_as_name (',' dotted_as_name)*
;;             | 'from' dotted_name 'import'
;;               ('*' | import_as_name (',' import_as_name)*)
import_stmt
  : IMPORT dotted_as_name_list
    (wisent-token $2 'import nil nil)
  | FROM dotted_name IMPORT star_or_import_as_name_list
    (wisent-token $2 'import nil nil)
  ;

;; dotted_as_name (',' dotted_as_name)*
dotted_as_name_list
  : dotted_as_name
  | dotted_as_name_list COMMA dotted_as_name
    (identity $1)
  ;

;; ('*' | import_as_name (',' import_as_name)*)
star_or_import_as_name_list
  : MULT
    ()
  | import_as_name_list
    ()
  ;

;; import_as_name (',' import_as_name)*
import_as_name_list
  : import_as_name
    ()
  | import_as_name_list COMMA import_as_name
    ()
  ;

;; import_as_name: NAME [NAME NAME]
import_as_name
  : NAME name_name_opt
    ()
  ;

;; dotted_as_name: dotted_name [NAME NAME]
dotted_as_name
  : dotted_name name_name_opt
    (identity $1)
  ;

;; [NAME NAME]
name_name_opt
  : ;;EMPTY
  | NAME NAME
    ()
  ;

;; dotted_name: NAME ('.' NAME)*
dotted_name
  : NAME
  | dotted_name PERIOD NAME
    (format "%s.%s" $1 $3)
  ;

;;;============================================================================
;;;@@ global_stmt
;;;============================================================================

;; global_stmt: 'global' NAME (',' NAME)*
global_stmt
  : GLOBAL comma_sep_name_list
    (wisent-token $1 'code nil nil)
  ;

;; NAME (',' NAME)*
comma_sep_name_list
  : NAME
  | comma_sep_name_list COMMA NAME
    (format "%s" $1)
  ;

;;;============================================================================
;;;@@ exec_stmt
;;;============================================================================

;; exec_stmt: 'exec' expr ['in' test [',' test]]
exec_stmt
  : EXEC expr exec_trailer
    (wisent-token $1 'code nil nil)
  ;

;; ['in' test [',' test]]
exec_trailer
  : ;;EMPTY
  | IN test comma_test_opt
    ()
  ;

;; [',' test]
comma_test_opt
  : ;;EMPTY
  | COMMA test
    ()
  ;

;;;============================================================================
;;;@@ assert_stmt
;;;============================================================================

;; assert_stmt: 'assert' test [',' test]
assert_stmt
  : ASSERT test comma_test_opt
    (wisent-token $1 'code nil nil)
  ;

;;;****************************************************************************
;;;@ compound_stmt
;;;****************************************************************************

compound_stmt
  : if_stmt
  | while_stmt
  | for_stmt
  | try_stmt
  | funcdef
  | classdef
  ;

;;;============================================================================
;;;@@ if_stmt
;;;============================================================================

;; if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
if_stmt
  : IF test COLON suite elif_suite_pair_list else_suite_pair_opt
    (wisent-token $1 'code nil nil)
  ;

;; ('elif' test ':' suite)*
elif_suite_pair_list
  : ;;EMPTY
  | elif_suite_pair_list ELIF test COLON suite
    ()
  ;

;; ['else' ':' suite]
else_suite_pair_opt
  : ;;EMPTY
  | ELSE COLON suite
    ()
  ;

;; This NT follows the COLON token for most compound statements.
;; suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
suite
  : simple_stmt
    (list $1)
  | NEWLINE INDENT stmt_oom DEDENT
    (nreverse $3)
  ;

;; stmt+   oom stands for One Or More
stmt_oom
  : stmt
    (list $1)
  | stmt_oom stmt
    (cons $2 $1)
  ;

;; stmt: simple_stmt | compound_stmt
stmt
  : simple_stmt
  | compound_stmt
  ;

;;;============================================================================
;;;@@ while_stmt
;;;============================================================================

;; while_stmt: 'while' test ':' suite ['else' ':' suite]
while_stmt
  : WHILE test COLON suite else_suite_pair_opt
    (wisent-token $1 'code nil nil)
  ;

;;;============================================================================
;;;@@ for_stmt
;;;============================================================================

;; for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
for_stmt
  : FOR exprlist IN testlist COLON suite else_suite_pair_opt
    (wisent-token $1 'code nil nil)
  ;

;;;============================================================================
;;;@@ try_stmt
;;;============================================================================

;; try_stmt: ('try' ':' suite (except_clause ':' suite)+ #diagram:break
;;            ['else' ':' suite] | 'try' ':' suite 'finally' ':' suite)
try_stmt
  : TRY COLON suite except_clause_suite_pair_list else_suite_pair_opt
    (wisent-token $1 'code nil nil)
  | TRY COLON suite FINALLY COLON suite
    (wisent-token $1 'code nil nil)
  ;

;; (except_clause ':' suite)+
except_clause_suite_pair_list
  : except_clause COLON suite
    (concat "except_clause_suite_pair_list")
  | except_clause_suite_pair_list except_clause COLON suite
    (concat "except_clause_suite_pair_list")
  ;

;; # NB compile.c makes sure that the default except clause is last
;; except_clause: 'except' [test [',' test]]
except_clause
  : EXCEPT zero_one_or_two_test
  ;

;; [test [',' test]]
zero_one_or_two_test
  : ;;EMPTY
  | test zero_or_one_comma_test
  ;

;;;============================================================================
;;;@@ funcdef
;;;============================================================================

;; funcdef: 'def' NAME parameters ':' suite
funcdef
 ;;  : DEF NAME parameters COLON suite
  : DEF NAME PAREN_BLOCK COLON suite
    (wisent-token $2 'function nil nil)
  ;

;; parameters: '(' [varargslist] ')'
parameters
  : LPAREN varargslist_opt RPAREN
    (format "%s" (or $2 ""))
  ;

;;;============================================================================
;;;@@ classdef
;;;============================================================================

;; classdef: 'class' NAME ['(' testlist ')'] ':' suite
classdef
  : CLASS NAME paren_testlist_opt COLON suite
    (wisent-token $2 'type $1 $5 nil)
  ;

;; ['(' testlist ')']
paren_testlist_opt
  : ;;EMPTY
 ;;| LPAREN testlist RPAREN
  | PAREN_BLOCK
  ;

;;;****************************************************************************
;;;@ test
;;;****************************************************************************

;; test: and_test ('or' and_test)* | lambdef
test
  : test_test
  | lambdef
  ;

;; and_test ('or' and_test)*
test_test
  : and_test
  | test_test OR and_test
    (format "%s %s %s" $1 $2 $3)
  ;

;; and_test: not_test ('and' not_test)*
and_test
  : not_test
  | and_test AND not_test
    (format "%s %s %s" $1 $2 $3)
  ;

;; not_test: 'not' not_test | comparison
not_test
  : NOT not_test
    (format "NOT %s" $1)
  | comparison
  ;

;; comparison: expr (comp_op expr)*
comparison
  : expr
  | comparison comp_op expr
    (format "%s %s %s" $1 $2 $3)
  ;

;; comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
comp_op
  : LT | GT | EQ | GE | LE | LTGT | NE | IN | NOT IN | IS | IS NOT
  ;

;; expr: xor_expr ('|' xor_expr)*
expr
  : xor_expr
  | expr BAR xor_expr
    (format "%s %s %s" $1 $2 $3)
  ;

;; xor_expr: and_expr ('^' and_expr)*
xor_expr
  : and_expr
  | xor_expr HAT and_expr
    (format "%s %s %s" $1 $2 $3)
  ;

;; and_expr: shift_expr ('&' shift_expr)*
and_expr
  : shift_expr
  | and_expr AMP shift_expr
    (format "%s %s %s" $1 $2 $3)
  ;

;; shift_expr: arith_expr (('<<'|'>>') arith_expr)*
shift_expr
  : arith_expr
  | shift_expr shift_expr_operators arith_expr
    (format "%s %s %s" $1 $2 $3)
  ;

;; ('<<'|'>>')
shift_expr_operators
  : LTLT
  | GTGT
  ;

;; arith_expr: term (('+'|'-') term)*
arith_expr
  : term
  | arith_expr plus_or_minus term
    (format "%s %s %s" $1 $2 $3)
  ;

;; ('+'|'-')
plus_or_minus
  : PLUS
  | MINUS
  ;

;; term: factor (('*'|'/'|'%'|'//') factor)*
term
  : factor
  | term term_operator factor
    (format "%s %s %s" $1 $2 $3)
  ;

term_operator
  : MULT
  | DIV
  | MOD
  | DIVDIV
  ;

;; factor: ('+'|'-'|'~') factor | power
factor
  : prefix_operators factor
    (format "%s %s" $1 $2)
  | power
  ;

;; ('+'|'-'|'~')
prefix_operators
  : PLUS
  | MINUS
  | TILDE
  ;

;; power: atom trailer* ('**' factor)*
power
  : atom trailer_zom exponent_zom
    (concat $1
	    (if $2 (concat " " $2 " ") "")
	    (if $3 (concat " " $3) "")
	    )
  ;

trailer_zom
  : ;;EMPTY
  | trailer_zom trailer
    (format "(%s %s)" (or $1 "") $2)
  ;

exponent_zom
  : ;;EMPTY
  | exponent_zom EXPONENT factor
    (format "(%s ** %s)" (or $1 "") $3)
  ;

;; trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
trailer
  : PAREN_BLOCK
  | BRACK_BLOCK
  | PERIOD NAME
    (concat "." $2)
  ;

;; atom: '(' [testlist] ')' | '[' [listmaker] ']' | '{' [dictmaker] '}'
;;     | '`' testlist '`'   | NAME | NUMBER | STRING+
atom
  : PAREN_BLOCK
    (format "%s" $1)
  | BRACK_BLOCK
    (format "%s" $1)
  | BRACE_BLOCK
    (format "%s" $1)
  | BACKQUOTE testlist BACKQUOTE
    ()
  | NAME
  | NUMBER_LITERAL
    (concat $1)
  | one_or_more_string
  ;

test_list_opt
  : ;;EMPTY
  | testlist
  ;

;; testlist: test (',' test)* [',']
testlist
  : comma_sep_test_list comma_opt
    (identity $1)
  ;

;; test (',' test)*
comma_sep_test_list
  : test
  | comma_sep_test_list COMMA test
    (format "%s, %s" $1 $3)
  ;

;; (read $1) and (read $2) were done before to peel away the double quotes.
;; However that does not work for single quotes, so it was taken out.
one_or_more_string
  : STRING_LITERAL
    (wisent-python-truncate-string $1)	;; limit string to 16 chars
  | one_or_more_string STRING_LITERAL
    (wisent-python-truncate-string (concat $1 $2)) ;; limit string to 16 chars
  ;

;;;****************************************************************************
;;;@ lambdef
;;;****************************************************************************

;; lambdef: 'lambda' [varargslist] ':' test
lambdef
  : LAMBDA varargslist_opt COLON test
    (format "%s %s %s" $1 $2 $3)
  ;

;; [varargslist]
varargslist_opt
  : ;;EMPTY
  | varargslist
  ;

;; varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME] | '**' NAME)
;;             | fpdef ['=' test] (',' fpdef ['=' test])* [',']
varargslist
  : fpdef_opt_test_list comma_mult_name_opt
    (format "%s %s" $1 (or $2 ""))
  | mult_name
  ;

;; [',' ('*' NAME [',' '**' NAME] | '**' NAME)]
comma_mult_name_opt
  : ;;EMPTY
  | COMMA mult_name
  ;

;; ('*' NAME [',' '**' NAME] | '**' NAME)
mult_name
  : MULT NAME multmult_name_opt
  | EXPONENT NAME
  ;

;; [',' '**' NAME]
multmult_name_opt
  : ;;EMPTY
  | COMMA EXPONENT NAME
    (format ", ** %s" $3)
  ;

;; fpdef ['=' test] (',' fpdef ['=' test])*
fpdef_opt_test_list
  : fpdef_opt_test
  | fpdef_opt_test_list COMMA fpdef_opt_test
    (format "%s, %s" $1 (or $3 ""))
  ;

;; fpdef ['=' test]
fpdef_opt_test
  : fpdef eq_test_opt
    (format "%s %S" $1 (or $2 ""))
  ;

;; fpdef: NAME | '(' fplist ')'
fpdef
  : NAME
  | LPAREN fplist RPAREN
    (format "(%s)" (or $2 ""))
  ;

;; fplist: fpdef (',' fpdef)* [',']
fplist
  : fpdef_list comma_opt
    (format "%s %s" (or $1 "") (or $2 ""))
  ;

;; fpdef (',' fpdef)*
fpdef_list
  : fpdef
  | fpdef_list COMMA fpdef
    (format "%s, %s" $1 $3)
  ;

;; ['=' test]
eq_test_opt
  : ;;EMPTY
  | ASSIGN test
    (format " = %s" $2)
  ;

;;;****************************************************************************
;;;@ Misc
;;;****************************************************************************

;; [',']
comma_opt
  : ;;EMPTY
  | COMMA
  ;

;; [';']
semicolon_opt
  : ;;EMPTY
  | SEMICOLON
  ;

;;; wisent-python.wy ends here
