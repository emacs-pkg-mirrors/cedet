\input texinfo   @c -*-texinfo-*-
@c
@c $Id: wisent.texi,v 1.12 2002/06/26 17:01:49 ponced Exp $
@c
@setfilename wisent.info
@settitle Wisent: the Bison-compatible Parser Generator for Emacs
@c Combine indices.
@synindex cp fn
@syncodeindex vr fn
@syncodeindex ky fn
@syncodeindex pg fn

@paragraphindent 0
@exampleindent   3

@copying
This manual documents Wisent, the Bison-compatible Parser Generator
for Emacs.

Some texts are borrowed or adapted from the manual of Bison version
1.35, updated 25 February 2002.

@iftex
Copyright @copyright{} 2001, 2002 David Ponce
Copyright @copyright{} 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1998,
1999, 2000, 2001 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being list their titles, with the Front-Cover Texts
being list, and with the Back-Cover Texts being list.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.
@end quotation
@end iftex
@end copying

@dircategory Emacs
@direntry
* Wisent: (wisent).	The Bison-compatible Parser Generator for Emacs
@end direntry

@titlepage
@sp 10
@center @titlefont{Wisent}
@author David Ponce (@email{david@dponce.com})
@vskip 0pt plus 1 fill
@insertcopying
@end titlepage

@node Top, Overview, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top Wisent

@insertcopying

@menu
* Overview::                    
* Grammar::                     
* Parsing::                     
* Wisent Bovine::               
* GNU Free Documentation License::  
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Grammar

* Grammar format::              
* Compiling a grammar::         
* Conflicts::                   
* Example::                     

Compiling a grammar

* Grammar Debugging::           

Parsing

* Writing a lexer::             
* Actions goodies::             
* Report errors::               
* Error recovery::              

How to use Wisent with Semantic

* WY grammar format::           
* WY Major Mode::               
* Grammar styles::              
* Wisent Flex::                 

WY grammar format

* Percent-keywords::            

Grammar styles

* Bovine style::                
* Bison style::                 
* Mixed style::                 

Bovine style

* Top level nonterminals::      
* Bovine style example::        

Bison style

* Bison style example::         

@end detailmenu
@end menu

@node Overview, Grammar, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Overview

@cindex Wisent overview
@cindex Wisent vs. Bison
Wisent (the European Bison) is an implementation in Emacs Lisp of the
GNU Compiler Compiler Bison. Its code is a port of the C code of GNU
Bison 1.28 & 1.31.

For more details on the basic concepts for understanding Wisent, it is
worthwhile to read the Bison Manual.@*
@ifhtml
@uref{http://www.gnu.org/manual/bison/html_node/index.html}.
@end ifhtml
@ifinfo
@inforef{Top, , bison.info}.
@end ifinfo

Wisent can generate compilers compatible with the Semantic tool set.@*
@inforef{Top, , semantic.info}.

It benefits of the main Bison's features:

@itemize @bullet
@item 
It uses a fast but not so space-efficient encoding for the parse
tables, described in Corbett's PhD thesis from Berkeley:

@quotation
@cite{Static Semantics in Compiler Error Recovery}@*
June 1985, Report No. UCB/CSD 85/251.
@end quotation

@item 
For generating the lookahead sets, Wisent uses the well-known
technique of F. DeRemer and A. Pennello they described in:

@quotation
@cite{Efficient Construction of LALR(1) Lookahead Sets}@*
October 1982, ACM TOPLS Vol 4 No 4.
@end quotation

@item 
Wisent resolves shift/reduce conflicts using operator precedence and
associativity.

@item 
Parser error recovery is accomplished using rules which match the
special token @code{error}.
@end itemize

Nevertheless there are some fundamental differences between Bison and
Wisent.

@itemize
@item
Wisent is intended to be used in Emacs.  It reads and produces Emacs
Lisp data structures.  All the additional code used in grammars is
Emacs Lisp code.
@item
Contrary to Bison, Wisent does not generate a parser which combines
Emacs Lisp code and grammar constructs.  They exist separately.
Wisent reads the grammar from a Lisp data structure and then generates
grammar constructs as tables.  Afterward, the derived tables can be
included and byte-compiled in separate Emacs Lisp files, and be used
at a later time by the Wisent's parser engine.
@item
Wisent allows multiple start nonterminals and allows a call to the
parsing function to be made for a particular start nonterminal.  For
example, this is particularly useful to parse a region of an Emacs
buffer.  Semantic heavily depends on the availability of this feature.
@end itemize

@node Grammar, Parsing, Overview, Top
@comment  node-name,  next,  previous,  up
@chapter Grammar

@cindex Context-free grammar
@cindex Nonterminal
@cindex Rule
@cindex Terminal
@cindex Token
In order for Wisent to parse a language, it must be described by a
@dfn{context-free grammar}.  That is a grammar specified as rules that
can be applied regardless of context.@*
Also @inforef{Language and Grammar, , bison.info}.

The formal grammar is formulated using @dfn{terminal} and
@dfn{nonterminal} items.  Terminals can be Emacs Lisp symbols or
characters, and nonterminals are symbols only.

Terminals (also known as @dfn{tokens}) represent the lexical
elements of the language like numbers, strings, etc..

For example @code{PLUS} can represent the operator @code{+}.

Nonterminal symbols are described by rules:

@example
RESULT @result{} COMPONENTS@dots{}
@end example

@var{RESULT} is a nonterminal that this rule describes and
@var{COMPONENTS} are various terminals and nonterminals that are put
together by this rule.

For example, this rule:

@example
exp @result{} exp PLUS exp
@end example

says that two groupings of type @code{exp}, with a @code{PLUS} token in
between, can be combined into a larger grouping of type @code{exp}.
 
@menu
* Grammar format::              
* Compiling a grammar::         
* Conflicts::                   
* Example::                     
@end menu

@node Grammar format, Compiling a grammar, Grammar, Grammar
@comment  node-name,  next,  previous,  up
@section Grammar format

@cindex Grammar format
@cindex Grammar coding conventions
@cindex Semantic actions
@cindex Middle-rule actions
@cindex Precedence level
@cindex Associativity
To be acceptable by Wisent a context-free grammars must respect a
particular format.  That is, must be represented as an Emacs Lisp list
of the form:

@code{(@var{TERMINALS} @var{ASSOCS} . @var{NON-TERMINALS})}

@table @var
@item TERMINALS
Is the list of terminal symbols used in the grammar.

@item ASSOCS
Specify the associativity of terminals like do the @code{%nonassoc},
@code{%left} and @code{%right} Bison's statements.@*
@inforef{Contextual Precedence, , bison.info}, for details.

It is @code{nil} or a list of elements of the form:

@code{(@var{ASSOC-TYPE} . @var{ASSOC-TERMS})}

where @var{ASSOC-TYPE} is the symbol @code{nonassoc}, @code{left} or
@code{right}, and @var{ASSOC-TERMS} is a list of terminal items.

@item NON-TERMINALS
Is the list of nonterminal definitions.  Each definition has the form:

@code{(@var{NONTERM} . @var{RULES})}

where @var{NONTERM} is the nonterminal symbol defined and
@var{RULES} the list of rules that describe this nonterminal.  Each
rule is a list:

@code{(@var{COMPONENTS} [@var{PRECEDENCE}] [@var{ACTION}])}

where:

@table @var
@item COMPONENTS
Is a list of various terminals and nonterminals that are put together
by this rule.

For example,

@example
(exp ((exp ?+ exp))          ;; exp: exp '+' exp
     )                       ;;    ;
@end example

says that two groupings of type @samp{exp}, with a @samp{+} token in
between, can be combined into a larger grouping of type @samp{exp}.
 
By convention, a nonterminal symbol should be in lower case, such as
@code{exp}, @code{stmt} or @code{declaration}.  Terminal symbols
should be upper case to distinguish them from nonterminals: for
example, @code{INTEGER}, @code{IDENTIFIER}, @code{IF} or
@code{RETURN}.  A terminal symbol that represents a particular keyword
in the language is conventionally the same as that keyword converted
to upper case.  The terminal symbol @code{error} is reserved for error
recovery.

Scattered among the components can be @dfn{middle-rule} actions.
Usually only @var{ACTION} is provided (@pxref{action}).

If @var{COMPONENTS} in a rule is @code{nil}, it means that the rule
can match the empty string.  For example, here is how to define a
comma-separated sequence of zero or more @samp{exp} groupings:

@example
(expseq  (nil)               ;; expseq: ;; empty
         ((expseq1))         ;;       | expseq1
         )                   ;;       ;

(expseq1 ((exp))             ;; expseq1: exp
         ((expseq1 ?, exp))  ;;        | expseq1 ',' exp
         )                   ;;        ;
@end example

@item PRECEDENCE
Is an optional vector of one terminal item.  The rule will be given
the precedence level of this terminal.  Notice that only terminals
declared in @var{ASSOCS} have a precedence level.  By default the rule
precedence is the one of the last terminal in it.@*
@inforef{Contextual Precedence, ,bison.info}, for more details.

It is important to understand that @var{ASSOCS} declarations defines
associativity but also assign a precedence level to terminals.  All
terminals declared in the same @code{left}, @code{right} or
@code{nonassoc} association get the same precedence level.  The
precedence level is increased at each new association.

On the other hand, @var{PRECEDENCE} explicitly assign the precedence
level of the given terminal to a rule.

@item @anchor{action}ACTION
An action is an optional Emacs Lisp function call, like this:

@code{(identity $1)}

The result of an action determines the semantic value of a rule.

From an implementation standpoint, the function call will be embedded
in a lambda expression, and several useful local variables will be
defined:

@vindex $N
@vindex $regionN
@vindex $region
@vindex $nterm
@table @code
@item $N
Where @var{N} is a positive integer.  Like in Bison, the value of
@code{$N} is the semantic value of the @var{N}th element of
@var{COMPONENTS}, starting from @code{1}.  It can be of any Lisp data
type.

@item $regionN
Where @var{N} is a positive integer.  For each @code{$N} variable
defined there is a corresponding @code{$regionN} variable.  Its value
is a pair @code{(@var{START-POS} .  @var{END-POS})} that represent the
start and end positions (in the lexical input stream) of the @code{$N}
value.  It can be @code{nil} when the component positions are not
available, like for an empty string component for example.

@item $region
Its value is the leftmost and rightmost positions of input data
matched by all @var{COMPONENTS} in the rule.  This is a pair
@code{(@var{LEFTMOST-POS} .  @var{RIGHTMOST-POS})}.  It can be
@code{nil} when components positions are not available.

@item $nterm
This variable is initialized with the nonterminal symbol
(@var{NONTERM}) the rule belongs to.  It could be useful to improve
error reporting or debugging.  It is used too, to automatically
provide the @code{reparse-symbol} property of a Semantic token
generated by the function @code{wisent-cooked-token}.@*
@xref{Wisent Bovine}, for details.
@end table

When an action is not specified a default value is supplied, it is
@code{(identity $1)}.  This means that the default semantic value of a
rule is the value of its first component.  Excepted for a rule
matching the empty string, for which the default action is to return
@code{nil}: @code{(identity nil)}.
@end table
@end table

@node Compiling a grammar, Conflicts, Grammar format, Grammar
@comment  node-name,  next,  previous,  up
@section Compiling a grammar

@cindex LALR(1) grammar
@cindex Grammar compilation
@cindex Compiling a grammar
@cindex Look-ahead token
After providing a context-free grammar in a suitable format, it must
be translated into a set of tables (an automaton) that will be used to
drive the parser.  Like Bison, Wisent translates grammars that must be
@dfn{LALR(1)}.

A grammar is LALR(1) if it is possible to tell how to parse any
portion of an input string with just a single token of look-ahead: the
@dfn{look-ahead token}.@*
@inforef{Language and Grammar, , bison.info}, for more information.

Grammar translation (compilation) is achieved by the function:

@findex wisent-compile-grammar
@vindex wisent-single-start-flag
@defun wisent-compile-grammar grammar &optional start-list
Compile @var{GRAMMAR} and return an LALR(1) automaton.

Optional argument @var{start-list} is a list of start symbols
(nonterminals).  If @code{nil} the first nonterminal defined in the
grammar is the default start symbol.  If @var{start-list} contains
only one element, it defines the start symbol.  If @var{start-list}
contains more than one element, all are defined as potential start
symbols, unless @code{wisent-single-start-flag} is non-@code{nil}.  In
that case the first element of @var{start-list} defines the start
symbol and others are ignored.

The LALR(1) automaton is a vector of the form:

@code{[@var{ACTIONS GOTOS FUNCTIONS TRANSLATE STARTS}]}

@table @var
@item ACTIONS
A state/token matrix telling the parser what to do at every state
based on the current look-ahead token.  That is shift, reduce, accept
or error.  See also @ref{Parsing}.
@item GOTOS
A state/nonterminal matrix telling the parser the next state to go to
after reducing with each rule.
@item FUNCTIONS
A vector of semantic actions.  A semantic action is actually an Emacs
Lisp function (lambda expression).  By default these functions are
byte-compiled to achieve best performance.  See also @ref{Grammar
Debugging}.
@item TRANSLATE
An alist which maps tokens returned by lexical analysis into item
numbers used internally.
@item STARTS
An alist which maps the allowed start symbols (nonterminals) to
lexical tokens that will be first shifted into the parser stack.
@end table
@end defun

@menu
* Grammar Debugging::           
@end menu

@node Grammar Debugging,  , Compiling a grammar, Compiling a grammar
@comment  node-name,  next,  previous,  up
@subsection Grammar Debugging

To help writing a new grammar, it is possible to tell
@code{wisent-compile-grammar} to produce a report containing verbose
descriptions of the grammar and parser (it is equivalent to the
@code{--verbose} option for Bison), by setting to non-@code{nil} this
variable:

@vindex wisent-verbose-flag
@defvar wisent-verbose-flag
Non-nil means to report verbose information on generated parser.
@end defvar

For performance reason, the code of semantic actions is byte-compiled
by default.  It is useful to prevent byte-compilation when you want to
debug action code by including calls to the Emacs debugger.  For that
you must set to non-@code{nil} this variable:

@vindex wisent-debug-flag
@defvar wisent-debug-flag
Non-@code{nil} means enable some debug stuff.
@end defvar

Note that when non-@code{nil}, @code{wisent-debug-flag} also enables
reporting of the content of some internal data structures.  This is
mainly useful to debug the grammar compiler itself.

@node Conflicts, Example, Compiling a grammar, Grammar
@comment  node-name,  next,  previous,  up
@section Conflicts

@cindex Grammar conflicts
@cindex Ambiguous grammar
@cindex Conflicts resolution
@cindex Shift/Reduce conflicts
@cindex Reduce/Reduce conflicts
Normally, a grammar should produce an automaton where at each state
the parser has only one action to do.@*
See @ref{Parsing}, for more information on parser actions.

In certain cases, a grammar can produce an automaton where, at some
states, there are more than one action possible.  A such grammar is
@dfn{ambiguous}, and generated @dfn{conflicts}.

The parser can't be driven by an automaton which isn't completely
@dfn{deterministic}, that is which contains conflicts.  It is
necessary to resolve the conflicts to eliminate them.  Wisent resolves
conflicts like Bison does.

There are two sorts of conflicts:

@table @dfn
@item shift/reduce conflicts
When either a shift or a reduction would be valid at the same state.

Such conflicts are resolved by choosing to shift, unless otherwise
directed by operator precedence declarations.@*
@inforef{Shift/Reduce , , bison.info}, for more information.

@item reduce/reduce conflicts
That occurs if there are two or more rules that apply to the same
sequence of input.  This usually indicates a serious error in the
grammar.

Such conflicts are resolved by choosing to use the rule that appears
first in the grammar, but it is very risky to rely on this.  Every
reduce/reduce conflict must be studied and usually eliminated.@*
@inforef{Reduce/Reduce , , bison.info}, for more information.
@end table

@node Example,  , Conflicts, Grammar
@comment  node-name,  next,  previous,  up
@section Example

@cindex Grammar example
Here is an example to parse simple infix arithmetic expressions.@*
@inforef{Infix Calc, Examples, bison.info}, for more details.

The full grammar in @dfn{WY} format (See @ref{WY grammar format}) is
available in the file @file{wisent-calc.wy}.

@example
%token <number> NUM

%nonassoc '=' ;; comparison
%left '-' '+'
%left '*' '/'
%left NEG     ;; negation--unary minus
%right '^'    ;; exponentiation

%%

input:
    line
  | input line
    (format "%s %s" $1 $2)
  ;

line:
    ';'
    @{";"@}
  | exp ';'
    (format "%s;" $1)
  ;

exp:
    NUM
    (string-to-number $1)
  | exp '=' exp
    (= $1 $3)
  | exp '+' exp
    (+ $1 $3)
  | exp '-' exp
    (- $1 $3)
  | exp '*' exp
    (* $1 $3)
  | exp '/' exp
    (/ $1 $3)
  | '-' exp %prec NEG
    (- $2)
  | exp '^' exp
    (expt $1 $3)
  | '(' exp ')'
    @{$2@}
  ;

%%
@end example

Here is the corresponding Lisp form accepted by
@code{wisent-compile-grammar}:

@lisp
'(
  ;; Terminals
  (NUM)
  
  ;; Terminal associativity & precedence
  ((nonassoc ?=)
   (left ?- ?+)
   (left ?* ?/)
   (left NEG)
   (right ?^))
  
  ;; Rules
  (input
   ((line))
   ((input line)
    (format "%s %s" $1 $2))
   )

  (line
   ((?;)
    (progn ";"))
   ((exp ?;)
    (format "%s;" $1))
   )

  (exp
   ((NUM)
    (string-to-number $1))
   ((exp ?= exp)
    (= $1 $3))
   ((exp ?+ exp)
    (+ $1 $3))
   ((exp ?- exp)
    (- $1 $3))
   ((exp ?* exp)
    (* $1 $3))
   ((exp ?/ exp)
    (/ $1 $3))
   ((?- exp) [NEG]
    (- $2))
   ((exp ?^ exp)
    (expt $1 $3))
   ((?\( exp ?\))
    (progn $2))
   )
  )
@end lisp

@node Parsing, Wisent Bovine, Grammar, Top
@comment  node-name,  next,  previous,  up
@chapter Parsing

@cindex Bottom-Up parser
@cindex Shift-Reduce parser
@cindex Table-driven parser
@cindex Shift
@cindex Reduce
The Wisent's parser is what is called a @dfn{bottom-up} or
@dfn{shift-reduce} parser which repeatedly:

@table @dfn
@item shift
That is pushes the value of the last lexical token read (the
look-ahead token) into a value stack, and reads a new one.
@item reduce
That is replaces a nonterminal by its semantic value.  The values of
the components which form the right hand side of a rule are popped
from the value stack and reduced by the semantic action of this rule.
The result is pushed back on top of value stack.
@end table

The parser will stop on:

@table @dfn
@item accept
When all input has been successfully parsed.  The semantic value of
the start nonterminal is on top of the value stack.
@item error
When a syntax error (an unexpected token in input) has been detected.
At this point the parser issues an error message and either stops or
calls a recovery routine to try to resume parsing.
@end table

The above elementary actions are driven by the LALR(1) automaton built
by @code{wisent-compile-grammar} from a context-free grammar.

The Wisent's parser is entered by calling the function:

@findex wisent-parse
@defun wisent-parse automaton lexer &optional error start
Parse input using the automaton specified in @var{automaton}.

@table @var
@item automaton
Is an LALR(1) automaton generated by @code{wisent-compile-grammar}.@*
@xref{Grammar}.
@item lexer
Is a function with no argument called by the parser to obtain the next
terminal (token) in input.@*
@xref{Writing a lexer}.
@item error
Is an optional reporting function called when a parse error occurs.
It receives a message string to report.  It defaults to the function
@code{error}.@*
@xref{Report errors}.
@item start
Specify the start symbol (nonterminal) used by the parser as its goal.
It defaults to the start symbol defined in the grammar.@*
@xref{Grammar}.
@end table
@end defun

@menu
* Writing a lexer::             
* Actions goodies::             
* Report errors::               
* Error recovery::              
@end menu

@node Writing a lexer, Actions goodies, Parsing, Parsing
@comment  node-name,  next,  previous,  up
@section What the parser must receive

@cindex Lexical analysis
@cindex Lexical tokens
@cindex Lexer
@cindex Scanner
It is important to understand that the parser does not parse
characters, but lexical tokens, and does not know anything about
characters and streams!

Reading input data to produce lexical tokens is performed by a lexer
(also called a scanner) in a lexical analysis step, before the syntax
analysis step performed by the parser.  The parser automatically calls
the lexer when it needs the next token to parse.

A Wisent's lexer is an Emacs Lisp function with no argument.  It must
return a valid lexical token of the form:

@code{(@var{SYMBOL VALUE} [@var{START} . @var{END}])}

@table @var
@item symbol
Is the unique symbol or character value identifying a terminal as
specified in the grammar (@pxref{Grammar}).
@item value
Is the actual value of @var{symbol}.  It can be of any valid Emacs
Lisp data type.
@item start
@itemx end
Are the optionals beginning and end positions of @var{value} in the
input stream.
@end table

@vindex wisent-eoi-term
When there are no more tokens to read the lexer must return the token
@code{(list wisent-eoi-term)} to each request.

@defvar wisent-eoi-term
Predefined constant, End-Of-Input terminal symbol.
@end defvar

@code{wisent-flex} is an example of a lexer that reads Semantic's
syntactic tokens and produces lexical tokens.@*
@xref{Wisent Flex}.

To call the lexer in a semantic action use the function
@code{wisent-lexer}.@*
@xref{Actions goodies}.

@node Actions goodies, Report errors, Writing a lexer, Parsing
@comment  node-name,  next,  previous,  up
@section Variables and macros useful in grammar actions.

@cindex Action goodies
@vindex wisent-input
@defvar wisent-input
The last token read.
The actual value of this variable is local to the parser.
@end defvar

@findex wisent-lexer
@defun wisent-lexer
Obtain the next terminal in input.
@end defun

@findex wisent-region
@defun wisent-region &rest positions
Return the start/end positions of the region including @var{POSITIONS}.
Each element of @var{POSITIONS} is a pair (@var{START-POS} .
@var{END-POS}) or nil.  The returned value is the pair
(@var{MIN-START-POS} . @var{MAX-END-POS}) or @code{nil} if no
@var{POSITIONS} are available.
@end defun

@node Report errors, Error recovery, Actions goodies, Parsing
@comment  node-name,  next,  previous,  up
@section The error reporting function

@cindex Error reporting
When the parser encounters a syntax error it calls a user-defined
function.  It must be an Emacs Lisp function with one argument: a
string containing the message to report.

By default the parser uses the standard Emacs Lisp function
@code{error} to report error message and terminate.

At this point the variable @code{wisent-input} contains the unexpected
token as returned by the lexer.

The error reporting function can be called from a semantic action too
using the special macro @code{wisent-error}.  When called from a
semantic action entered by error recovery (@pxref{Error recovery}) the
value of the variable @code{wisent-recovering} is non-nil.

@node Error recovery,  , Report errors, Parsing
@comment  node-name,  next,  previous,  up
@section Error recovery

@cindex Error recovery
@cindex Error recovery strategy
@cindex Error recovery actions
@cindex error token
The error recovery mechanism of the Wisent's parser conforms to the
one Bison uses.@*
@inforef{Error Recovery, , bison.info}, for details.
 
To recover from a syntax error you must write rules to recognize the
special token @code{error}.  This is a terminal symbol that is
automatically defined and reserved for error handling.

When the parser encounters a syntax error, it pops the state stack
until it finds a state that allows shifting the @code{error} token.
After it has been shifted, if the old look-ahead token is not
acceptable to be shifted next, the parser reads tokens and discards
them until it finds a token which is acceptable.

Strategies for error recovery depend on the choice of error rules in
the grammar.  A simple and useful strategy is simply to skip the rest
of the current statement if an error is detected:

@example
(stmnt (( error ?; )) ;; on error, skip until ';' is read
       )
@end example

It is also useful to recover to the matching close-delimiter of an
opening-delimiter that has already been parsed:

@example
(primary (( ?@{ expr  ?@} ))
         (( ?@{ error ?@} ))
         @dots{}
         )
@end example

Note that error recovery rules may have actions, just as any other
rules can.  Here are some predefined variables and functions or macros
useful in such actions:

@vindex wisent-nerrs
@defvar wisent-nerrs
The number of parse errors encountered so far.
@end defvar

@vindex wisent-recovering
@defvar wisent-recovering
Non-@code{nil} when the parser is recovering.
The actual value of this variable is local to the parser.
@end defvar

@findex wisent-error
@defun wisent-error msg
Call the language specific error reporting function with message
@var{MSG} (@pxref{Report errors}).

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-errok
@defun wisent-errok
Resume generating error messages immediately for subsequent syntax
errors.

The parser suppress error message for syntax errors that happens
shortly after the first, until three consecutive input tokens have
been successfully shifted.

Calling @code{wisent-errok} in an action, make error messages resume
immediately.  No error messages will be suppressed if you call it in
an error rule's action.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-clearin
@defun wisent-clearin
Discard the current look-ahead token.
This will cause a new token to be read.

In an error rule's action the previous look-ahead token is reanalyzed
immediately.  @code{wisent-clearin} may be called to clear this token.

For example, suppose that on a parse error, an error handling routine
is called that advances the input stream to some point where parsing
should once again commence.  The next symbol returned by the lexical
scanner is probably correct.  The previous look-ahead token ought to
be discarded with @code{wisent-clearin}.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-set-region
@defun wisent-set-region start end
Change the region of text matched by the current nonterminal.
@var{START} and @var{END} are respectively the beginning and end
positions of the region occupied by the group of components associated
to this nonterminal.  If @var{START} or @var{END} values are not a
valid positions the region is set to nil.

For example, the function @code{wisent-skip-block} described below
uses it to safely set the region to the start/end positions of the
current block of code.
@end defun

@findex wisent-skip-token
@defun wisent-skip-token
Skip an invalid token and try to continue parsing.

It is implemented like this:

@lisp
(defsubst wisent-skip-token ()
  "Skip an invalid token and try to continue parsing.
To be used in grammar recovery actions."
  (wisent-error (format "Skipping invalid '%s'" $nterm))
  ;; Clear the lookahead token
  (if (eq (car wisent-input) wisent-eoi-term)
      ;; does nothing at EOI to avoid infinite recovery loop
      nil
    (run-hook-with-args 'wisent-skip-token-hook wisent-input)
    (wisent-clearin)
    (wisent-errok)))
@end lisp
@end defun

@findex wisent-skip-block
@defun wisent-skip-block
Safely skip a block and try to continue parsing.
A block is data between an open-delimiter (syntax class @code{(}) and
a matching close-delimiter (syntax class @code{)}):

@example
(a parenthesized block)
[a block between brackets]
@{a block between braces@}
@end example

The following example uses @code{wisent-skip-block} to safely skip a
block delimited by @samp{LBRACE} (@code{@{}) and @samp{RBRACE}
(@code{@}}) tokens:

@example
(block ((LBRACE RBRACE))
       ((LBRACE error)
        (wisent-skip-block))
       )
@end example
@end defun

@node Wisent Bovine, GNU Free Documentation License, Parsing, Top
@comment  node-name,  next,  previous,  up
@chapter How to use Wisent with Semantic

@cindex How to use Wisent with Semantic
@cindex Wisent vs. Semantic
@cindex Semantic syntax tree
@cindex Semantic token
This chapter presents how the Wisent's parser can be used to produce
@dfn{syntax trees} for the Semantic tool set.

A Semantic syntax tree is a hierarchy of Emacs Lisp data structures,
called @dfn{Semantic tokens}, that describes a program in a way
independent of programming languages.  Semantic tokens can be seen as
@dfn{tags} that map program declarations, like functions, methods,
variables, data types, classes, includes, grammar rules, etc..

@menu
* WY grammar format::           
* WY Major Mode::               
* Grammar styles::              
* Wisent Flex::                 
@end menu

@node WY grammar format, WY Major Mode, Wisent Bovine, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section WY grammar format

@cindex WY grammar format
@cindex WY grammar specification
A convenient way to use the Wisent parser with Semantic is to define
your grammar in @dfn{WY} form.  The WY grammar format is very close
to the format used to describe a Bison's grammar.  The main
differences are:

@itemize @bullet
@item
The use of Emacs Lisp syntax in place of C like syntax.
@item
Semantic specific Percent-keywords.
@end itemize

So, if you are already familiar with Bison and have some knowledge of
Emacs Lisp, writing WY grammars is straightforward ;-)@*
See also @ref{WY Major Mode}.

A good way to describe the WY grammar format, and to see how it looks,
is to show its specification as a WY grammar:

@example
%start grammar

;; Keywords
%token LEFT            "left"
%token NONASSOC        "nonassoc"
%token PREC            "prec"
%token PUT             "put"
%token RIGHT           "right"
%token START           "start"
%token TOKEN           "token"
%token LANGUAGEMODE    "languagemode"
%token OUTPUTFILE      "outputfile"
%token SETUPFUNCTION   "setupfunction"
%token KEYWORDTABLE    "keywordtable"
%token PARSETABLE      "parsetable"
%token TOKENTABLE      "tokentable"

;; Literals
%token <string>        STRING
%token <symbol>        SYMBOL
%token <number>        NUMBER
%token <char>          CHARACTER

;; Blocks
%token <semantic-list> PAREN_BLOCK "^("
%token <semantic-list> BRACE_BLOCK "^@{"

;; Parens
%token <open-paren>    LBRACE      "@{"
%token <close-paren>   RBRACE      "@}"

;; Punctuations
%token <punctuation>   COLON       ":"
%token <punctuation>   SEMI        ";"
%token <punctuation>   OR          "|"
%token <punctuation>   LT          "<"
%token <punctuation>   GT          ">"
%token <punctuation>   PERCENT     "%"

%%

grammar:
    PERCENT
  | code
  | declaration
  | nonterminal
  ;

code:
    PAREN_BLOCK
  | BRACE_BLOCK
  ;

declaration:
    languagemode_decl
  | outputfile_decl
  | setupfunction_decl
  | keywordtable_decl
  | parsetable_decl
  | tokentable_decl
  | token_decl
  | start_decl
  | left_decl
  | right_decl
  | nonassoc_decl
  | put_decl
  ;

languagemode_decl:
    LANGUAGEMODE symbols
  ;

outputfile_decl:
    OUTPUTFILE string_value
  ;

string_value:
    STRING
  ;

setupfunction_decl:
    SETUPFUNCTION any_symbol
  ;

keywordtable_decl:
    KEYWORDTABLE any_symbol
  ;

parsetable_decl:
    PARSETABLE any_symbol
  ;

tokentable_decl:
    TOKENTABLE any_symbol
  ;

token_decl:
    TOKEN token_type_opt any_symbol string_value
  | TOKEN token_type_opt symbols
  ;

token_type_opt:
  ;; EMPTY
  | token_type
  ;

token_type:
    LT any_symbol GT
  ;

start_decl:
    START symbols
  ;

left_decl:
    LEFT token_type_opt items
  ;

right_decl:
    RIGHT token_type_opt items
  ;

nonassoc_decl:
    NONASSOC token_type_opt items
  ;

put_decl:
    PUT any_symbol put_value
  | PUT any_symbol put_value_list
  | PUT put_name_list put_value
  | PUT put_name_list put_value_list
  ;

put_name_list:
    BRACE_BLOCK
  ;

put_names:
    LBRACE
  | RBRACE
  | any_symbol
  ;

put_value_list:
    BRACE_BLOCK
  ;

put_values:
    LBRACE
  | RBRACE
  | put_value
  ;

put_value:
    any_symbol any_value
  ;

any_value:
    any_symbol
  | STRING
  | NUMBER
  | PAREN_BLOCK
  ;

symbols:
    symbols any_symbol
  | any_symbol
  ;

nonterminal:
    any_symbol COLON rules SEMI
  ;

rules:
    rules OR rule
  | rule
  ;

rule:
 ;; empty
  | rule item
  | rule action
  | rule level
  ;

level:
    PERCENT PREC item
  ;

action:
    PAREN_BLOCK
  | BRACE_BLOCK
  ;

items:
    items item
  | item
  ;

item:
    any_symbol
  | CHARACTER
  ;

any_symbol:
    SYMBOL
  | LEFT
  | NONASSOC
  | PREC
  | PUT
  | RIGHT
  | START
  | TOKEN
  | LANGUAGEMODE
  | OUTPUTFILE
  | SETUPFUNCTION
  | KEYWORDTABLE
  | PARSETABLE
  | TOKENTABLE
  ;
@end example

Notice that comments are like Emacs Lisp ones but start with two
consecutive semicolons (@code{;;}) instead of a single one.  Because
the single semicolon (@code{;}) is the end of rule delimiter.

Also the WY grammar accepts single character literals as terminals
in C-like syntax  (the
@samp{CHARACTER} tokens in the above grammar).  For
example, the following are valid character literals:

@example
'+', '-', ')', ';'    ;; punctuations
'\n', ' '             ;; whitespaces
@end example

See also @ref{Example}.

@menu
* Percent-keywords::            
@end menu

@node Percent-keywords,  , WY grammar format, WY grammar format
@comment  node-name,  next,  previous,  up
@subsection Percent-keywords

@cindex %keywordtable
@cindex %languagemode
@cindex %left
@cindex %nonassoc
@cindex %outputfile
@cindex %parsetable
@cindex %prec
@cindex %put
@cindex %right
@cindex %setupfunction
@cindex %start
@cindex %token
@cindex %tokentable

@table @code
@item %outputfile @var{file-name}
Required declaration that specifies the name of an Emacs Lisp source
file where to put Lisp code generated from the current grammar.
@var{file-name} must be a string.

@item %parsetable @var{variable-name}
Name of the variable set with the generated parser automaton.

@item %keywordtable @var{variable-name}
Name of the variable set with the generated table of keywords.

@item %tokentable @var{variable-name}
Name of the variable set with the generated table of tokens.

@item %setupfunction @var{function-name}
Name of the function where to put the generated setup code.

@item %languagemode @var{mode-name}@dots{}
Names of major modes where Semantic uses the Wisent's parser with this
grammar.

@item %start @var{nonterminal}@dots{}
Declare the nonterminal start symbols.

@item %token @var{terminal} @var{string-value}
Declare language keywords.  These terminal symbols are stored in the
variable declared by @code{%keywordtable}.

@item %token <@var{type}> @var{terminal} [@var{string-value}]
@itemx %token [<@var{type}>] @var{terminal}@dots{}
Declare terminal symbols that aren't keywords.  They are stored in
the variable declared by @code{%tokentable}.

@item %put @{@var{terminal}@dots{}@} @{@var{property value}@dots{}@}
@itemx %put @var{terminal} @{@var{property value}@dots{}@}
@itemx %put @{@var{terminal}@dots{}@} @var{property value}
@itemx %put @var{terminal} @var{property value}
Give properties to tokens.

@item %left @var{terminal}@dots{}
@itemx %right @var{terminal}@dots{}
@itemx %nonassoc @var{terminal}@dots{}
Assign associativity and precedence level to terminals.

@item %prec @var{terminal}
Assign @var{terminal} precedence level to current rule.  @code{%prec}
must be only used in a rule, like this:

@example
exp:
  @dots{}
  | '-' exp %prec NEG
  @dots{}
  ;
@end example
@end table

@node WY Major Mode, Grammar styles, WY grammar format, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section WY Major Mode

@cindex WY Major Mode
@findex wy-mode
@findex wisent-wy-mode
A major mode (@code{wy-mode} or @code{wisent-wy-mode}) provides syntax
highlighting, automatic indentation, and useful commands to help
writing WY files with Emacs, and to automatically generate the grammar
in Lisp form with the declarations needed by Semantic.

An interesting feature is that @code{wy-mode} is Semantic-enabled and
the WY grammar is defined in a WY file: @file{wisent-wy.wy}!

The following commands are defined:

@findex wisent-wy-update-outputfile
@deffn Command wisent-wy-update-outputfile
Create or update grammar Lisp code in output file.

Use this command to automatically update or generate the file
specified in the @code{%outputfile} statement of the WY grammar in the
current buffer.

The variables named by the @code{%parsetable}, @code{%keywordtable}
and @code{%tokentable} declarations are updated with Lisp data
generated from the rules, the @code{%start}, @code{%left},
@code{%right}, @code{%nonassoc} and @code{%token}/@code{%put}
declarations found in the grammar.

The function named by the @code{%setupfunction} declaration is updated
with the Emacs Lisp open code (not in rule actions) found in the
grammar.  It can be Lisp function calls enclosed in @code{(@dots{})}
or blocks (equivalent of @code{(progn @dots{})}) enclosed in
@code{@{@dots{}@}}.  Also Semantic is configured to use the Wisent
parser instead of its default one.  Normally, the
@code{%setupfunction} will be run as a major mode hook to enable
Semantic for this particular programming language.

@end deffn

@node Grammar styles, Wisent Flex, WY Major Mode, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section Grammar styles

@cindex Grammar styles
Semantic bovination heavily depends on how you wrote the grammar.
There are mainly two styles to write a Wisent's grammar intended to be
used with the Semantic tool set: the @dfn{Bovine style} and the
@dfn{Bison style}.  Each one has pros and cons, and in certain cases
it can be worth a mix of the two styles!

@menu
* Bovine style::                
* Bison style::                 
* Mixed style::                 
@end menu

@node Bovine style, Bison style, Grammar styles, Grammar styles
@comment  node-name,  next,  previous,  up
@subsection Bovine style

@cindex Grammar bovine style
@cindex Semantic token, Raw
@cindex Semantic token, Cooked
The @dfn{bovine style} is the preferred style to use with Semantic.
It relies on the bovinator back-end mechanism which parses top-level
nonterminals one at a time and automagically skip unexpected lexical
tokens in input.

Each top-level nonterminal must produces a @dfn{raw semantic token} by
calling the function @code{wisent-token} with the appropriate
parameters.

Bovination then automatically translate raw tokens into @dfn{cooked
semantic tokens}, updating the raw token structure with internal
properties and buffer related data.

After parsing completed it results in a list of cooked tokens which
becomes the value of @code{semantic-toplevel-bovine-cache}.

@findex wisent-token
@defun wisent-token &rest return-val
Return a raw Semantic token including @var{RETURN-VAL}.
Should be used in Semantic actions to build the bovine cache.
@end defun

@menu
* Top level nonterminals::      
* Bovine style example::        
@end menu

@node Top level nonterminals, Bovine style example, Bovine style, Bovine style
@comment  node-name,  next,  previous,  up
@subsubsection Top level nonterminals

@cindex Top level nonterminals
To be done!

@node Bovine style example,  , Top level nonterminals, Bovine style
@comment  node-name,  next,  previous,  up
@subsubsection Bovine style example

@cindex Grammar bovine style example
The following example is a snippet of the bovine style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java-tags.wy}.

@example
formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;

formal_parameters
  : LPAREN
    ()
  | RPAREN
    ()
  | formal_parameter COMMA
  | formal_parameter RPAREN
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-token $3 'variable $2 nil
                  (ASSOC typemodifiers $1)
                  nil)
  ;
@end example

It shows the use of the @code{EXPANDFULL} built-in function to parse a
@samp{PAREN_BLOCK} which contains a @samp{formal_parameter_list}.
Actually, @code{EXPANDFULL} tells to recursively bovinate
@samp{formal_parameters} inside @samp{PAREN_BLOCK}.  The parser then
iterates until it digested all available input data inside the
@samp{PAREN_BLOCK}, trying to match any of the
@samp{formal_parameters} rules:

@itemize
@item
@samp{LPAREN}
@item
@samp{RPAREN}
@item
@samp{formal_parameter COMMA}
@item
@samp{formal_parameter RPAREN}
@end itemize

At each iteration it will return a @samp{formal_parameter} raw token,
or nil to skip unwanted (single @samp{LPAREN} or @samp{RPAREN} for
example) or unexpected input data.

@node Bison style, Mixed style, Bovine style, Grammar styles
@comment  node-name,  next,  previous,  up
@subsection Bison style

@cindex Grammar Bison style
What we call the @dfn{Bison style} is actually the traditional style
of Bison's grammars.  Compared to bovine style, it is not
straightforward to use grammars written in Bison style in Semantic.
Mainly because such grammars are designed to parse the whole input
data in one pass, and don't use the bovinator back-end mechanism
(@pxref{Bovine style}).  With Bison style the parser is called once to
parse the grammar start symbol, which is the only known top-level
nonterminal.

The first consequence is that syntax errors are not automatically
handled by Semantic.  Thus, it is necessary to explicitly handle them
at the grammar level, providing error recovery rules to skip
unexpected input data.

The second consequence is that the bovinator can't do automatic raw to
cooked token translation, excepted for the start nonterminal value.
So it is also necessary to explicitly return cooked semantic tokens
from concerned semantic actions by calling the function
@code{wisent-cooked-token} with the appropriate parameters.

@findex wisent-cooked-token
@defun wisent-cooked-token &rest return-val
Return a cooked Semantic token including @var{RETURN-VAL}.
Should be used in Semantic actions to build the bovine cache.
@end defun

@menu
* Bison style example::         
@end menu

@node Bison style example,  , Bison style, Bison style
@comment  node-name,  next,  previous,  up
@subsubsection Bison style example

@cindex Grammar Bison style example
The following example is a snippet of the Bison style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java.wy}.

@example
formal_parameter_list
  : formal_parameter_list COMMA formal_parameter
    (cons $3 $1)
  | formal_parameter
    (list $1)
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-cooked-token $3 'variable $2 nil
                         (ASSOC typemodifiers $1)
                         nil)
  ;
@end example

@node Mixed style,  , Bison style, Grammar styles
@comment  node-name,  next,  previous,  up
@subsection Mixed style

@cindex Grammar mixed style
The following example is a snippet of the WY format grammar provided
in the Semantic distribution in the file @file{wisent-wy.wy}.

@example
%start grammar
@dots{}

grammar:
  @dots{}
  | nonterminal
  ;
@dots{}

nonterminal:
    any_symbol COLON rules SEMI
    (wisent-token $1 'nonterminal nil $3 nil)
  | error SEMI
  ;

rules:
    lifo_rules
    (apply #'nconc (nreverse $1))
  ;

lifo_rules:
    lifo_rules OR rule
    (cons $3 $1)
  | rule
    (list $1)
  ;

rule:
    rhs
    @dots{}
    (wisent-cooked-token name 'rule type comps prec action nil)
  ;
@end example

This example shows how Bovine and Bison styles can be combined in the
same grammar to obtain a good compromise between grammar complexity
and an efficient parsing strategy in an interactive environment.

@code{nonterminal} is parsed using normal bovination via the main
@code{grammar} rule.  The semantic action calls @code{wisent-token} to
produce a Semantic raw token, automagically cooked by Semantic.

But @code{rules} part is parsed in Bison style! Why?

Rule delimiters are the colon (@code{:}), that follows the nonterminal
name, and a final semicolon (@code{;}).  Unfortunately these
delimiters naturally are not @code{open-paren}/@code{close-paren}
type, and Emacs syntactic analyzer can't easily isolate data between
them to produce a @code{semantic-list} token.  Consequently it is not
possible to use @code{EXPANDFULL} to bovinate @code{RULES_PART}, like
this:

@example
nonterminal:
    any_symbol COLON rules SEMI
    (wisent-token $1 'nonterminal nil $3 nil)
  ;

rules:
    RULES_PART  ;; @strong{Map a @code{semantic-list} syntactic token}
    (EXPANDFULL $1 'rules)
  ;

rules:
    COLON
    ()
    OR
    ()
    SEMI
    ()
    rhs
    @dots{}
    (wisent-token name 'rule type comps prec action nil)
  ;
@end example

In such cases, when it is difficult for Emacs to obtain
@code{semantic-list} syntactic tokens, the best solution is to use
traditional Bison style with error recovery!

@node Wisent Flex,  , Grammar styles, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section The Wisent Flex lexer

@cindex Wisent Flex lexer
@cindex Token mapping
@cindex wisent-flex vs. semantic-flex
@cindex Token table
@cindex Keyword table
@cindex Token mapping properties
@findex wisent-flex
@defun wisent-flex
Return the next available lexical token.

@vindex wisent-flex-istream
Eat syntactic tokens produced by @code{semantic-flex}, available in
variable @code{wisent-flex-istream}, and return Wisent's lexical
tokens.

See documentation of @code{semantic-flex-tokens} for details on the
syntactic tokens returned by @code{semantic-flex}.

In most cases one syntactic token is mapped to one lexical token.  But
in certain cases several successive syntactic tokens can be mapped to
one lexical tokens.  A common case is given by arithmetic operators
which can be made of multiple punctuations.

Also the mapping between syntactic tokens and lexical ones uses regexp
match by default, but can use string comparison too.
@end defun

The rules specifying how to do the mapping are defined in the
following two symbol tables:

@vindex semantic-flex-keywords-obarray
@defvar semantic-flex-keywords-obarray
The keyword table.
@end defvar

@vindex wisent-flex-tokens-obarray
@defvar wisent-flex-tokens-obarray
The token table.
@end defvar

Keywords are directly mapped to equivalent Wisent's lexical tokens
like this (@var{SF}- prefix means @code{semantic-flex}, @var{WF}-
@code{wisent-flex}):

@example
@w{(@var{SF-KEYWORD start} . @var{end})
@result{} (@var{WF-KEYWORD} "name" @var{start} . @var{end})}
@end example

Mapping of other tokens obeys to rules in the token table.  Here is an
example on how to define the mapping of @code{punctuation} syntactic
tokens.

@enumerate
@item
Add (@code{intern}) the symbol @code{punctuation} into the token
table.

@item
Set its value to the mapping rules to use.  Mapping rules are an alist
of @code{(@var{WF-TOKEN} . @var{MATCHER})} elements.  @var{WF-TOKEN} is the
category of the Wisent's lexical token (for example @samp{'OPERATOR}).
@var{MATCHER} is the regular expression used to filter input data (for
example @samp{"[+-]"}).  The first element of the mapping rule alist
defines a default matching rule. It must be @code{nil} or have the
form @code{(@var{WF-TOKEN})}.  When there is no mapping rule that matches
the syntactic token value, the default @var{WF-TOKEN} or @code{nil} is
returned.

Thus, if the syntactic token symbol @code{'punctuation} has the
mapping rules @code{(nil (OPERATOR . "[+-]"))}, the following token:

@example
(punctuation 1 . 2)
@end example

will be mapped to the lexical token

@example
(OPERATOR "+" 1 . 2)
@end example

if the buffer contained @samp{+} between positions 1 and 2.

To define multiple matchers for the same @var{WF-TOKEN} just give
several @code{(@var{WF-TOKEN} . @var{MATCHER})} values.
@var{MATCHER}s will be tried in sequence until one matches.

@item
Optionally customize how @code{wisent-flex} will interpret mapping
rules, using symbol properties.

The following properties are recognized:

@table @code
@item string
If non-@code{nil} MATCHERs are interpreted as strings instead of
regexps, and matching uses direct string comparison.  This could speed
up things in certain cases.

@item multiple
non-@code{nil} indicates to lookup at multiple successive syntactic
tokens and try to match the longest one.

@item char-literal
non-@code{nil} indicates to return the first character of the
syntactic token value as the lexical token category.  It is the
default for punctuation, open-paren and close-paren syntactic tokens.
Use this property when grammar contains references to character
literals.

@item handler
If non-@code{nil} must specify a function with no argument that will
be called first to map the syntactic token.  It must return a lexical
token or @code{nil}, and update the input stream in variable
@code{wisent-flex-istream} accordingly.
@end table

The following example maps multiple punctuations to operators and use
string comparison:

@example
(let ((entry (intern 'punctuation token-table)))
  (set entry '(nil ;; No default mapping
               (LSHIFT . "<<") (RSHIFT . ">>")
               (LT     . "<")  (GT     . ">")))
  (put entry 'string   t)
  (put entry 'multiple t))
@end example
@end enumerate

@node GNU Free Documentation License, Index, Wisent Bovine, Top
@comment  node-name,  next,  previous,  up
@appendix GNU Free Documentation License

@include fdl.texi

@node Index,  , GNU Free Documentation License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index

@printindex fn

@c Print the tables of contents
@summarycontents
@contents
@c That's all
@bye

@c  LocalWords:  Wisent automagically bovination bovinate
